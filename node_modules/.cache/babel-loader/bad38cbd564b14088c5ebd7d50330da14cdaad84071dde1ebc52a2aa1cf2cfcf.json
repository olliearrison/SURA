{"ast":null,"code":"import * as THREE from 'three';\nexport default function InfiniteGridHelper(size1, size2, color, distance) {\n  color = new THREE.Color(color || 'white');\n  size1 = size1 || 10;\n  size2 = size2 || 100;\n  distance = distance || 8000;\n  const geometry = new THREE.PlaneBufferGeometry(2, 2, 1, 1);\n  const material = new THREE.ShaderMaterial({\n    side: THREE.DoubleSide,\n    uniforms: {\n      uSize1: {\n        value: size1\n      },\n      uSize2: {\n        value: size2\n      },\n      uColor: {\n        value: color\n      },\n      uDistance: {\n        value: distance\n      }\n    },\n    transparent: true,\n    vertexShader: `\n           varying vec3 worldPosition;\n           uniform float uDistance;\n           \n           void main() {\n                vec3 pos = position.xyz * uDistance;\n                worldPosition = pos;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n           }\n           `,\n    fragmentShader: `\n           varying vec3 worldPosition;\n           uniform float uSize1;\n           uniform float uSize2;\n           uniform vec3 uColor;\n           uniform float uDistance;\n           \n            float getGrid(float size) {\n                vec2 r = worldPosition.xz / size;\n                vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);\n                float line = min(grid.x, grid.y);\n                return 1.0 - min(line, 1.0);\n            }\n            \n            float getLineThickness(float size) {\n                float thickness = size / 5.0;\n                return thickness;\n            }\n            \n           void main() {\n                float d = 1.0 - min(distance(cameraPosition.xz, worldPosition.xz) / uDistance, 1.0);\n                float g1 = getGrid(uSize1) * getLineThickness(uSize1);\n                float g2 = getGrid(uSize2) * getLineThickness(uSize2);\n                gl_FragColor = vec4(uColor.rgb, mix(g2, g1, g1) * pow(d, 3.0));\n                gl_FragColor.a = mix(0.5 * gl_FragColor.a, gl_FragColor.a, g2);\n                if ( gl_FragColor.a <= 0.0 ) discard;\n           }\n           `,\n    extensions: {\n      derivatives: true\n    }\n  });\n  let grid = new THREE.Mesh(geometry, material);\n  grid.frustumCulled = false;\n  return grid;\n}","map":{"version":3,"names":["THREE","InfiniteGridHelper","size1","size2","color","distance","Color","geometry","PlaneBufferGeometry","material","ShaderMaterial","side","DoubleSide","uniforms","uSize1","value","uSize2","uColor","uDistance","transparent","vertexShader","fragmentShader","extensions","derivatives","grid","Mesh","frustumCulled"],"sources":["/Users/olliearrison/Desktop/v1/src/components/InfiniteGridHelper.js"],"sourcesContent":["import * as THREE from 'three';\n\nexport default function InfiniteGridHelper(size1, size2, color, distance) {\n    color = new THREE.Color(color || 'white');\n    size1 = size1 || 10;\n    size2 = size2 || 100;\n    distance = distance || 8000;\n\n    const geometry = new THREE.PlaneBufferGeometry(2, 2, 1, 1);\n\n    const material = new THREE.ShaderMaterial({\n        side: THREE.DoubleSide,\n        uniforms: {\n            uSize1: {\n                value: size1\n            },\n            uSize2: {\n                value: size2\n            },\n            uColor: {\n                value: color\n            },\n            uDistance: {\n                value: distance\n            }\n        },\n        transparent: true,\n        vertexShader: `\n           varying vec3 worldPosition;\n           uniform float uDistance;\n           \n           void main() {\n                vec3 pos = position.xyz * uDistance;\n                worldPosition = pos;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n           }\n           `,\n        fragmentShader: `\n           varying vec3 worldPosition;\n           uniform float uSize1;\n           uniform float uSize2;\n           uniform vec3 uColor;\n           uniform float uDistance;\n           \n            float getGrid(float size) {\n                vec2 r = worldPosition.xz / size;\n                vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);\n                float line = min(grid.x, grid.y);\n                return 1.0 - min(line, 1.0);\n            }\n            \n            float getLineThickness(float size) {\n                float thickness = size / 5.0;\n                return thickness;\n            }\n            \n           void main() {\n                float d = 1.0 - min(distance(cameraPosition.xz, worldPosition.xz) / uDistance, 1.0);\n                float g1 = getGrid(uSize1) * getLineThickness(uSize1);\n                float g2 = getGrid(uSize2) * getLineThickness(uSize2);\n                gl_FragColor = vec4(uColor.rgb, mix(g2, g1, g1) * pow(d, 3.0));\n                gl_FragColor.a = mix(0.5 * gl_FragColor.a, gl_FragColor.a, g2);\n                if ( gl_FragColor.a <= 0.0 ) discard;\n           }\n           `,\n        extensions: {\n            derivatives: true\n        }\n    });\n\n    let grid = new THREE.Mesh(geometry, material);\n    grid.frustumCulled = false;\n    return grid;\n}\n"],"mappings":"AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAE9B,eAAe,SAASC,kBAAkBA,CAACC,KAAK,EAAEC,KAAK,EAAEC,KAAK,EAAEC,QAAQ,EAAE;EACtED,KAAK,GAAG,IAAIJ,KAAK,CAACM,KAAK,CAACF,KAAK,IAAI,OAAO,CAAC;EACzCF,KAAK,GAAGA,KAAK,IAAI,EAAE;EACnBC,KAAK,GAAGA,KAAK,IAAI,GAAG;EACpBE,QAAQ,GAAGA,QAAQ,IAAI,IAAI;EAE3B,MAAME,QAAQ,GAAG,IAAIP,KAAK,CAACQ,mBAAmB,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EAE1D,MAAMC,QAAQ,GAAG,IAAIT,KAAK,CAACU,cAAc,CAAC;IACtCC,IAAI,EAAEX,KAAK,CAACY,UAAU;IACtBC,QAAQ,EAAE;MACNC,MAAM,EAAE;QACJC,KAAK,EAAEb;MACX,CAAC;MACDc,MAAM,EAAE;QACJD,KAAK,EAAEZ;MACX,CAAC;MACDc,MAAM,EAAE;QACJF,KAAK,EAAEX;MACX,CAAC;MACDc,SAAS,EAAE;QACPH,KAAK,EAAEV;MACX;IACJ,CAAC;IACDc,WAAW,EAAE,IAAI;IACjBC,YAAY,EAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;IACJC,cAAc,EAAG;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;IACJC,UAAU,EAAE;MACRC,WAAW,EAAE;IACjB;EACJ,CAAC,CAAC;EAEF,IAAIC,IAAI,GAAG,IAAIxB,KAAK,CAACyB,IAAI,CAAClB,QAAQ,EAAEE,QAAQ,CAAC;EAC7Ce,IAAI,CAACE,aAAa,GAAG,KAAK;EAC1B,OAAOF,IAAI;AACf"},"metadata":{},"sourceType":"module","externalDependencies":[]}