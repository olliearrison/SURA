{"ast":null,"code":"import \"core-js/modules/esnext.typed-array.to-reversed.js\";\nimport \"core-js/modules/esnext.typed-array.to-sorted.js\";\nimport \"core-js/modules/esnext.typed-array.with.js\";\nimport * as THREE from \"three\";\nimport { MeshLine, MeshLineMaterial, MeshLineRaycast } from \"three.meshline\";\nimport { drawSceneList, camera, canvas } from \"../App.vue\";\nimport { grid } from \"./GridBackground.vue\";\nimport { index, canvasIndex } from './DrawingInput.vue';\nlet draw = {\n  l: undefined,\n  draw: class {\n    constructor(stroke) {\n      this.stroke = stroke;\n      this.line = new MeshLine();\n      this.geometry = new THREE.BufferGeometry();\n      this.vertices = [];\n      this.lineWidths = [];\n      this.geometry.setAttribute(\"position\", new THREE.BufferAttribute(new Float32Array(this.vertices), 3));\n      //this.geometry.setAttribute(\"widthCallback\", new THREE.BufferAttribute(new Float32Array(this.lineWidths), 1));\n\n      this.material = new MeshLineMaterial({\n        lineWidth: this.stroke.show_stroke ? this.stroke.lineWidth : .01,\n        sizeAttenuation: 1,\n        color: this.stroke.show_stroke ? this.stroke.color : 0xFFFFFF,\n        side: THREE.DoubleSide,\n        fog: true,\n        wireframe: false,\n        alphaTest: 0.9,\n        blending: THREE.NormalBlending,\n        transparent: false,\n        resolution: new THREE.Vector2(window.innerWidth, window.innerHeight),\n        repeat: new THREE.Vector2(.1, .1),\n        opacity: 1\n      });\n      this.mesh = new THREE.Mesh(this.line.geometry, this.material);\n      this.mesh.raycast = MeshLineRaycast;\n      this.eraserGroup = new THREE.Group();\n    }\n    translate(x, y) {\n      var vec = new THREE.Vector3();\n\n      // from stackoverflow\n      vec.set(x / window.innerWidth * 2 - 1, -(y / window.innerHeight) * 2 + 1, 4);\n      const raycaster = new THREE.Raycaster();\n      raycaster.setFromCamera(vec, camera);\n      var intersects = raycaster.intersectObject(canvas[canvasIndex]);\n      const intersectPoints = intersects.map(intersection => intersection.point);\n      return intersectPoints;\n    }\n    start() {\n      drawSceneList[index].add(this.mesh);\n    }\n    move(x, y, z, stroke) {\n      //var v3 = this.translate(x, y, z);\n      this.vertices = [...this.vertices, x, y, z];\n      this.geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(this.vertices), 3));\n      //console.log(this.vertices);\n      // This updates the MeshLine's geometry\n      var width = stroke.lineWidth;\n      this.lineWidths = [...this.lineWidths, width];\n      var widthCallback = p => {\n        return this.lineWidths[Math.floor(p * this.lineWidths.length)];\n      };\n      this.line.setGeometry(this.geometry, widthCallback);\n    }\n    erase(x, y) {\n      var vec = new THREE.Vector3();\n\n      // from stackoverflow\n      vec.set(x / window.innerWidth * 2 - 1, -(y / window.innerHeight) * 2 + 1, .5);\n      const raycaster = new THREE.Raycaster();\n      raycaster.params.Line.threshold = .1;\n\n      //raycaster.near = 0; // Set the minimum distance for intersection (default is 0)\n      //raycaster.far = 5; // Set the maximum distance for intersection (increase/decrease as needed)\n\n      raycaster.setFromCamera(vec, camera);\n      var intersects = raycaster.intersectObjects(drawSceneList[index].children, false);\n\n      //const intersectPoints = intersects.map((intersection) => intersection.point);\n      for (var i = 0; i < intersects.length; i++) {\n        var intersectedObject = intersects[i].object;\n        if (intersectedObject !== canvas[canvasIndex] && intersectedObject !== grid) {\n          drawSceneList[index].remove(intersectedObject);\n          this.eraserGroup.add(intersectedObject);\n          console.log(\"removed\");\n        }\n      }\n    }\n    end(eraser) {\n      if (this.vertices.length >= 3) {\n        this.geometry.computeBoundingBox();\n      }\n      if (eraser) {\n        if (this.eraserGroup.children.length === 0) {\n          return [false, false];\n        }\n        return ['remove', this.eraserGroup];\n      } else {\n        if (this.geometry === undefined || this.vertices.length === 0) {\n          return [false, false];\n        }\n        console.log(this.mesh.id);\n        console.log(\"ahhhhhhhhhhh*****\");\n        return ['add', this.mesh.id];\n      }\n    }\n  },\n  onStart: function (x, y, stroke) {\n    if (stroke.eraser) {\n      this.l.erase(x, y);\n    } else {\n      this.l = new this.draw(stroke);\n      var coor = this.l.translate(x, y);\n      if (coor.length > 0) {\n        this.l.move(coor[0].x, coor[0].y, coor[0].z, stroke);\n        this.l.start();\n      }\n    }\n  },\n  onMove: function (x, y, stroke) {\n    if (this.l !== undefined) {\n      if (stroke.eraser) {\n        this.l.erase(x, y);\n      } else {\n        var coor = this.l.translate(x, y);\n        if (coor.length > 0) {\n          this.l.move(coor[0].x, coor[0].y, coor[0].z, stroke);\n        }\n      }\n    }\n  },\n  onEnd: function (stroke) {\n    return this.l.end(stroke.eraser);\n  }\n};\nexport { draw };","map":{"version":3,"names":["THREE","MeshLine","MeshLineMaterial","MeshLineRaycast","drawSceneList","camera","canvas","grid","index","canvasIndex","draw","l","undefined","constructor","stroke","line","geometry","BufferGeometry","vertices","lineWidths","setAttribute","BufferAttribute","Float32Array","material","lineWidth","show_stroke","sizeAttenuation","color","side","DoubleSide","fog","wireframe","alphaTest","blending","NormalBlending","transparent","resolution","Vector2","window","innerWidth","innerHeight","repeat","opacity","mesh","Mesh","raycast","eraserGroup","Group","translate","x","y","vec","Vector3","set","raycaster","Raycaster","setFromCamera","intersects","intersectObject","intersectPoints","map","intersection","point","start","add","move","z","width","widthCallback","p","Math","floor","length","setGeometry","erase","params","Line","threshold","intersectObjects","children","i","intersectedObject","object","remove","console","log","end","eraser","computeBoundingBox","id","onStart","coor","onMove","onEnd"],"sources":["C:/Users/peopl/Documents/Arduino/6d2/SURA/src/components/DrawHelper.js"],"sourcesContent":["import * as THREE from \"three\";\r\nimport { MeshLine, MeshLineMaterial, MeshLineRaycast } from \"three.meshline\";\r\nimport { drawSceneList, camera, canvas } from \"../App.vue\";\r\nimport { grid } from \"./GridBackground.vue\";\r\nimport { index, canvasIndex } from './DrawingInput.vue';\r\n\r\nlet draw = {\r\n    l: undefined,\r\n    draw: class {\r\n        constructor(stroke) {\r\n            this.stroke = stroke;\r\n            this.line = new MeshLine();\r\n            this.geometry = new THREE.BufferGeometry();\r\n            this.vertices = [];\r\n            this.lineWidths = [];\r\n            this.geometry.setAttribute(\"position\", new THREE.BufferAttribute(new Float32Array(this.vertices), 3));\r\n            //this.geometry.setAttribute(\"widthCallback\", new THREE.BufferAttribute(new Float32Array(this.lineWidths), 1));\r\n            \r\n            this.material = new MeshLineMaterial({\r\n                lineWidth: this.stroke.show_stroke ? this.stroke.lineWidth : .01,\r\n                sizeAttenuation: 1,\r\n                color: this.stroke.show_stroke ? this.stroke.color : 0xFFFFFF,\r\n                side: THREE.DoubleSide,\r\n                fog: true,\r\n                wireframe: false,\r\n                alphaTest: 0.9,\r\n                blending: THREE.NormalBlending,\r\n                transparent: false,\r\n                resolution: new THREE.Vector2(window.innerWidth, window.innerHeight),\r\n                repeat: new THREE.Vector2(.1, .1),\r\n                opacity: 1,\r\n            });\r\n            this.mesh = new THREE.Mesh(this.line.geometry, this.material);\r\n            this.mesh.raycast = MeshLineRaycast;\r\n            this.eraserGroup = new THREE.Group();\r\n\r\n        }\r\n\r\n\r\n        translate(x, y) {\r\n          \r\n            var vec = new THREE.Vector3();\r\n    \r\n            // from stackoverflow\r\n            vec.set(\r\n                ( x / window.innerWidth ) * 2 - 1,\r\n                - ( y / window.innerHeight ) * 2 + 1,\r\n                4 );\r\n\r\n            const raycaster = new THREE.Raycaster();\r\n            raycaster.setFromCamera( vec, camera );\r\n            var intersects = raycaster.intersectObject( canvas[canvasIndex] );\r\n            \r\n            const intersectPoints = intersects.map((intersection) => intersection.point);\r\n            return intersectPoints;\r\n                    \r\n        }\r\n\r\n        start() {\r\n            drawSceneList[index].add(this.mesh);\r\n        }\r\n\r\n        move(x, y, z, stroke) {\r\n            //var v3 = this.translate(x, y, z);\r\n            this.vertices = [...this.vertices, x, y, z];\r\n            this.geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(this.vertices), 3));\r\n            //console.log(this.vertices);\r\n              // This updates the MeshLine's geometry\r\n            var width = stroke.lineWidth;\r\n            \r\n            this.lineWidths = [...this.lineWidths, width];\r\n            \r\n            var widthCallback = (p) => {\r\n                return this.lineWidths[Math.floor(p * this.lineWidths.length)];\r\n            };\r\n\r\n            this.line.setGeometry(this.geometry, widthCallback);\r\n        }\r\n\r\n        erase(x, y) {\r\n            var vec = new THREE.Vector3();\r\n    \r\n            // from stackoverflow\r\n            vec.set(\r\n                ( x / window.innerWidth ) * 2 - 1,\r\n                - ( y / window.innerHeight ) * 2 + 1,\r\n                .5 );\r\n\r\n            const raycaster = new THREE.Raycaster();\r\n            raycaster.params.Line.threshold = .1;\r\n\r\n            //raycaster.near = 0; // Set the minimum distance for intersection (default is 0)\r\n            //raycaster.far = 5; // Set the maximum distance for intersection (increase/decrease as needed)\r\n\r\n\r\n            raycaster.setFromCamera( vec, camera );\r\n            var intersects = raycaster.intersectObjects(drawSceneList[index].children, false);\r\n            \r\n            //const intersectPoints = intersects.map((intersection) => intersection.point);\r\n            for (var i = 0; i < intersects.length; i++) {\r\n                var intersectedObject = intersects[i].object;\r\n                if (intersectedObject !== canvas[canvasIndex] && intersectedObject !== grid) {\r\n                    drawSceneList[index].remove(intersectedObject);\r\n                    this.eraserGroup.add(intersectedObject);\r\n                    console.log(\"removed\");\r\n                }\r\n                \r\n            }\r\n\r\n\r\n        }\r\n\r\n        end(eraser) {\r\n            if (this.vertices.length >= 3) {\r\n                this.geometry.computeBoundingBox();\r\n            }\r\n            if (eraser){\r\n                if (this.eraserGroup.children.length === 0) {\r\n                    return [false, false];\r\n                }\r\n\r\n                return ['remove', this.eraserGroup];\r\n            } else {\r\n                if (this.geometry === undefined || this.vertices.length === 0) {\r\n                    return [false, false];\r\n                }\r\n                console.log(this.mesh.id);\r\n                console.log(\"ahhhhhhhhhhh*****\");\r\n                return ['add', this.mesh.id];\r\n            }\r\n        }\r\n\r\n    },\r\n    onStart: function (x, y, stroke) {\r\n\r\n        if (stroke.eraser){\r\n            this.l.erase(x, y);\r\n        } else {\r\n            this.l = new this.draw(stroke);\r\n\r\n        var coor = this.l.translate(x, y);\r\n\r\n        if (coor.length > 0)\r\n        {\r\n            this.l.move(coor[0].x, coor[0].y, coor[0].z, stroke);\r\n            this.l.start();\r\n        }\r\n    }\r\n        \r\n    },\r\n    onMove: function (x, y, stroke) {\r\n\r\n        \r\n        if(this.l !== undefined) {\r\n            if (stroke.eraser){\r\n                this.l.erase(x, y);\r\n            } else {\r\n\r\n                var coor = this.l.translate(x, y);\r\n                if (coor.length > 0)\r\n                {\r\n                    this.l.move(coor[0].x, coor[0].y, coor[0].z, stroke);\r\n                }\r\n            }\r\n        }\r\n        \r\n    },\r\n    onEnd: function (stroke) {\r\n        return this.l.end(stroke.eraser);\r\n    },\r\n}\r\n\r\nexport { draw }\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}