{"ast":null,"code":"import * as THREE from 'three';\n\n// Author: Fyrestar https://mevedia.com (https://github.com/Fyrestar/THREE.InfiniteGridHelper)\nexport default function InfiniteGridHelper(size1, size2, color, distance, axes = 'xzy') {\n  color = color || new THREE.Color('white');\n  size1 = size1 || 10;\n  size2 = size2 || 100;\n  distance = distance || 8000;\n  const planeAxes = axes.substr(0, 2);\n  const geometry = new THREE.PlaneBufferGeometry(2, 2, 1, 1);\n  const material = new THREE.ShaderMaterial({\n    side: THREE.DoubleSide,\n    uniforms: {\n      uSize1: {\n        value: size1\n      },\n      uSize2: {\n        value: size2\n      },\n      uColor: {\n        value: color\n      },\n      uDistance: {\n        value: distance\n      }\n    },\n    transparent: true,\n    vertexShader: `\n           \n           varying vec3 worldPosition;\n\t\t   \n           uniform float uDistance;\n           \n           void main() {\n           \n                vec3 pos = position.${axes} * uDistance;\n                pos.${planeAxes} += cameraPosition.${planeAxes};\n                \n                worldPosition = pos;\n                \n                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n           \n           }\n           `,\n    fragmentShader: `\n           \n           varying vec3 worldPosition;\n           \n           uniform float uSize1;\n           uniform float uSize2;\n           uniform vec3 uColor;\n           uniform float uDistance;\n            \n            \n            \n            float getGrid(float size) {\n            \n                vec2 r = worldPosition.${planeAxes} / size;\n                \n                \n                vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);\n                float line = min(grid.x, grid.y);\n                \n            \n                return 1.0 - min(line, 1.0);\n            }\n            \n           void main() {\n           \n                \n                  float d = 1.0 - min(distance(cameraPosition.${planeAxes}, worldPosition.${planeAxes}) / uDistance, 1.0);\n                \n                  float g1 = getGrid(uSize1);\n                  float g2 = getGrid(uSize2);\n                  \n                  \n                  gl_FragColor = vec4(uColor.rgb, mix(g2, g1, g1) * pow(d, 3.0));\n                  gl_FragColor.a = mix(0.5 * gl_FragColor.a, gl_FragColor.a, g2);\n                \n                  if ( gl_FragColor.a <= 0.0 ) discard;\n                \n           \n           }\n           \n           `,\n    extensions: {\n      derivatives: true\n    }\n  });\n\n  // THREE.Mesh.call( this, geometry, material );\n\n  // this.frustumCulled = false;\n\n  let grid = new THREE.Mesh(geometry, material);\n  grid.frustumCulled = false;\n  return grid;\n}\nInfiniteGridHelper.prototype = {\n  ...THREE.Mesh.prototype,\n  ...THREE.Object3D.prototype,\n  ...THREE.EventDispatcher.prototype\n};","map":{"version":3,"names":["THREE","InfiniteGridHelper","size1","size2","color","distance","axes","Color","planeAxes","substr","geometry","PlaneBufferGeometry","material","ShaderMaterial","side","DoubleSide","uniforms","uSize1","value","uSize2","uColor","uDistance","transparent","vertexShader","fragmentShader","extensions","derivatives","grid","Mesh","frustumCulled","prototype","Object3D","EventDispatcher"],"sources":["/Users/olliearrison/Desktop/v1/src/components/InfiniteGridHelper.js"],"sourcesContent":["import * as THREE from 'three'\n\n// Author: Fyrestar https://mevedia.com (https://github.com/Fyrestar/THREE.InfiniteGridHelper)\nexport default function InfiniteGridHelper(size1, size2, color, distance, axes = 'xzy') {\n\n    color = color || new THREE.Color('white');\n    size1 = size1 || 10;\n    size2 = size2 || 100;\n\n    distance = distance || 8000;\n\n\n\n    const planeAxes = axes.substr(0, 2);\n\n    const geometry = new THREE.PlaneBufferGeometry(2, 2, 1, 1);\n\n    const material = new THREE.ShaderMaterial({\n\n        side: THREE.DoubleSide,\n\n        uniforms: {\n            uSize1: {\n                value: size1\n            },\n            uSize2: {\n                value: size2\n            },\n            uColor: {\n                value: color\n            },\n            uDistance: {\n                value: distance\n            }\n        },\n        transparent: true,\n        vertexShader: `\n           \n           varying vec3 worldPosition;\n\t\t   \n           uniform float uDistance;\n           \n           void main() {\n           \n                vec3 pos = position.${axes} * uDistance;\n                pos.${planeAxes} += cameraPosition.${planeAxes};\n                \n                worldPosition = pos;\n                \n                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n           \n           }\n           `,\n\n\n        fragmentShader: `\n           \n           varying vec3 worldPosition;\n           \n           uniform float uSize1;\n           uniform float uSize2;\n           uniform vec3 uColor;\n           uniform float uDistance;\n            \n            \n            \n            float getGrid(float size) {\n            \n                vec2 r = worldPosition.${planeAxes} / size;\n                \n                \n                vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);\n                float line = min(grid.x, grid.y);\n                \n            \n                return 1.0 - min(line, 1.0);\n            }\n            \n           void main() {\n           \n                \n                  float d = 1.0 - min(distance(cameraPosition.${planeAxes}, worldPosition.${planeAxes}) / uDistance, 1.0);\n                \n                  float g1 = getGrid(uSize1);\n                  float g2 = getGrid(uSize2);\n                  \n                  \n                  gl_FragColor = vec4(uColor.rgb, mix(g2, g1, g1) * pow(d, 3.0));\n                  gl_FragColor.a = mix(0.5 * gl_FragColor.a, gl_FragColor.a, g2);\n                \n                  if ( gl_FragColor.a <= 0.0 ) discard;\n                \n           \n           }\n           \n           `,\n\n        extensions: {\n            derivatives: true\n        }\n\n    });\n\n\n    // THREE.Mesh.call( this, geometry, material );\n\n    // this.frustumCulled = false;\n\n    let grid = new THREE.Mesh(geometry, material);\n\n    grid.frustumCulled = false;\n\n    return grid\n\n}\n\nInfiniteGridHelper.prototype = {\n    ...THREE.Mesh.prototype,\n    ...THREE.Object3D.prototype,\n    ...THREE.EventDispatcher.prototype\n};"],"mappings":"AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;;AAE9B;AACA,eAAe,SAASC,kBAAkBA,CAACC,KAAK,EAAEC,KAAK,EAAEC,KAAK,EAAEC,QAAQ,EAAEC,IAAI,GAAG,KAAK,EAAE;EAEpFF,KAAK,GAAGA,KAAK,IAAI,IAAIJ,KAAK,CAACO,KAAK,CAAC,OAAO,CAAC;EACzCL,KAAK,GAAGA,KAAK,IAAI,EAAE;EACnBC,KAAK,GAAGA,KAAK,IAAI,GAAG;EAEpBE,QAAQ,GAAGA,QAAQ,IAAI,IAAI;EAI3B,MAAMG,SAAS,GAAGF,IAAI,CAACG,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC;EAEnC,MAAMC,QAAQ,GAAG,IAAIV,KAAK,CAACW,mBAAmB,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EAE1D,MAAMC,QAAQ,GAAG,IAAIZ,KAAK,CAACa,cAAc,CAAC;IAEtCC,IAAI,EAAEd,KAAK,CAACe,UAAU;IAEtBC,QAAQ,EAAE;MACNC,MAAM,EAAE;QACJC,KAAK,EAAEhB;MACX,CAAC;MACDiB,MAAM,EAAE;QACJD,KAAK,EAAEf;MACX,CAAC;MACDiB,MAAM,EAAE;QACJF,KAAK,EAAEd;MACX,CAAC;MACDiB,SAAS,EAAE;QACPH,KAAK,EAAEb;MACX;IACJ,CAAC;IACDiB,WAAW,EAAE,IAAI;IACjBC,YAAY,EAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsCjB,IAAK;AAC3C,sBAAsBE,SAAU,sBAAqBA,SAAU;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;IAGJgB,cAAc,EAAG;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyChB,SAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgEA,SAAU,mBAAkBA,SAAU;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;IAEJiB,UAAU,EAAE;MACRC,WAAW,EAAE;IACjB;EAEJ,CAAC,CAAC;;EAGF;;EAEA;;EAEA,IAAIC,IAAI,GAAG,IAAI3B,KAAK,CAAC4B,IAAI,CAAClB,QAAQ,EAAEE,QAAQ,CAAC;EAE7Ce,IAAI,CAACE,aAAa,GAAG,KAAK;EAE1B,OAAOF,IAAI;AAEf;AAEA1B,kBAAkB,CAAC6B,SAAS,GAAG;EAC3B,GAAG9B,KAAK,CAAC4B,IAAI,CAACE,SAAS;EACvB,GAAG9B,KAAK,CAAC+B,QAAQ,CAACD,SAAS;EAC3B,GAAG9B,KAAK,CAACgC,eAAe,CAACF;AAC7B,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}