{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/* eslint-disable */\n\nimport { GridHelper, EllipseCurve, BufferGeometry, Line, LineBasicMaterial, Raycaster, Group, Box3, Sphere, Quaternion, Vector2, Vector3, Matrix4, MathUtils, EventDispatcher } from 'three';\n\n//trackball state\nconst STATE = {\n  IDLE: Symbol(),\n  ROTATE: Symbol(),\n  PAN: Symbol(),\n  SCALE: Symbol(),\n  FOV: Symbol(),\n  FOCUS: Symbol(),\n  ZROTATE: Symbol(),\n  TOUCH_MULTI: Symbol(),\n  ANIMATION_FOCUS: Symbol(),\n  ANIMATION_ROTATE: Symbol()\n};\nconst INPUT = {\n  NONE: Symbol(),\n  ONE_FINGER: Symbol(),\n  ONE_FINGER_SWITCHED: Symbol(),\n  TWO_FINGER: Symbol(),\n  MULT_FINGER: Symbol(),\n  CURSOR: Symbol()\n};\n\n//cursor center coordinates\nconst _center = {\n  x: 0,\n  y: 0\n};\n\n//transformation matrices for gizmos and camera\nconst _transformation = {\n  camera: new Matrix4(),\n  gizmos: new Matrix4()\n};\n\n//events\nconst _changeEvent = {\n  type: 'change'\n};\nconst _startEvent = {\n  type: 'start'\n};\nconst _endEvent = {\n  type: 'end'\n};\nconst _raycaster = new Raycaster();\nconst _offset = new Vector3();\nconst _gizmoMatrixStateTemp = new Matrix4();\nconst _cameraMatrixStateTemp = new Matrix4();\nconst _scalePointTemp = new Vector3();\n/**\n *\n * @param {Camera} camera Virtual camera used in the scene\n * @param {HTMLElement} domElement Renderer's dom element\n * @param {Scene} scene The scene to be rendered\n */\nclass ArcballControls extends EventDispatcher {\n  constructor(camera, domElement, scene = null) {\n    super();\n    this.camera = null;\n    this.domElement = domElement;\n    this.scene = scene;\n    this.target = new Vector3();\n    this._currentTarget = new Vector3();\n    this.radiusFactor = 0.67;\n    this.mouseActions = [];\n    this._mouseOp = null;\n\n    //global vectors and matrices that are used in some operations to avoid creating new objects every time (e.g. every time cursor moves)\n    this._v2_1 = new Vector2();\n    this._v3_1 = new Vector3();\n    this._v3_2 = new Vector3();\n    this._m4_1 = new Matrix4();\n    this._m4_2 = new Matrix4();\n    this._quat = new Quaternion();\n\n    //transformation matrices\n    this._translationMatrix = new Matrix4(); //matrix for translation operation\n    this._rotationMatrix = new Matrix4(); //matrix for rotation operation\n    this._scaleMatrix = new Matrix4(); //matrix for scaling operation\n\n    this._rotationAxis = new Vector3(); //axis for rotate operation\n\n    //camera state\n    this._cameraMatrixState = new Matrix4();\n    this._cameraProjectionState = new Matrix4();\n    this._fovState = 1;\n    this._upState = new Vector3();\n    this._zoomState = 1;\n    this._nearPos = 0;\n    this._farPos = 0;\n    this._gizmoMatrixState = new Matrix4();\n\n    //initial values\n    this._up0 = new Vector3();\n    this._zoom0 = 1;\n    this._fov0 = 0;\n    this._initialNear = 0;\n    this._nearPos0 = 0;\n    this._initialFar = 0;\n    this._farPos0 = 0;\n    this._cameraMatrixState0 = new Matrix4();\n    this._gizmoMatrixState0 = new Matrix4();\n\n    //pointers array\n    this._button = -1;\n    this._touchStart = [];\n    this._touchCurrent = [];\n    this._input = INPUT.NONE;\n\n    //two fingers touch interaction\n    this._switchSensibility = 32; //minimum movement to be performed to fire single pan start after the second finger has been released\n    this._startFingerDistance = 0; //distance between two fingers\n    this._currentFingerDistance = 0;\n    this._startFingerRotation = 0; //amount of rotation performed with two fingers\n    this._currentFingerRotation = 0;\n\n    //double tap\n    this._devPxRatio = 0;\n    this._downValid = true;\n    this._nclicks = 0;\n    this._downEvents = [];\n    this._downStart = 0; //pointerDown time\n    this._clickStart = 0; //first click time\n    this._maxDownTime = 250;\n    this._maxInterval = 300;\n    this._posThreshold = 24;\n    this._movementThreshold = 24;\n\n    //cursor positions\n    this._currentCursorPosition = new Vector3();\n    this._startCursorPosition = new Vector3();\n\n    //grid\n    this._grid = null; //grid to be visualized during pan operation\n    this._gridPosition = new Vector3();\n\n    //gizmos\n    this._gizmos = new Group();\n    this._curvePts = 128;\n\n    //animations\n    this._timeStart = -1; //initial time\n    this._animationId = -1;\n\n    //focus animation\n    this.focusAnimationTime = 500; //duration of focus animation in ms\n\n    //rotate animation\n    this._timePrev = 0; //time at which previous rotate operation has been detected\n    this._timeCurrent = 0; //time at which current rotate operation has been detected\n    this._anglePrev = 0; //angle of previous rotation\n    this._angleCurrent = 0; //angle of current rotation\n    this._cursorPosPrev = new Vector3(); //cursor position when previous rotate operation has been detected\n    this._cursorPosCurr = new Vector3(); //cursor position when current rotate operation has been detected\n    this._wPrev = 0; //angular velocity of the previous rotate operation\n    this._wCurr = 0; //angular velocity of the current rotate operation\n\n    //parameters\n    this.adjustNearFar = false;\n    this.scaleFactor = 1.1; //zoom/distance multiplier\n    this.dampingFactor = 25;\n    this.wMax = 20; //maximum angular velocity allowed\n    this.enableAnimations = true; //if animations should be performed\n    this.enableGrid = false; //if grid should be showed during pan operation\n    this.cursorZoom = false; //if wheel zoom should be cursor centered\n    this.minFov = 5;\n    this.maxFov = 90;\n    this.enabled = true;\n    this.enablePan = true;\n    this.enableRotate = true;\n    this.enableZoom = true;\n    this.enableGizmos = true;\n    this.minDistance = 0;\n    this.maxDistance = Infinity;\n    this.minZoom = 0;\n    this.maxZoom = Infinity;\n\n    //trackball parameters\n    this._tbRadius = 1;\n\n    //FSA\n    this._state = STATE.IDLE;\n    this.setCamera(camera);\n    if (this.scene != null) {\n      this.scene.add(this._gizmos);\n    }\n    this.domElement.style.touchAction = 'none';\n    this._devPxRatio = window.devicePixelRatio;\n    this.initializeMouseActions();\n    this._onContextMenu = onContextMenu.bind(this);\n    this._onWheel = onWheel.bind(this);\n    this._onPointerUp = onPointerUp.bind(this);\n    this._onPointerMove = onPointerMove.bind(this);\n    this._onPointerDown = onPointerDown.bind(this);\n    this._onPointerCancel = onPointerCancel.bind(this);\n    this._onWindowResize = onWindowResize.bind(this);\n    this.domElement.addEventListener('contextmenu', this._onContextMenu);\n    this.domElement.addEventListener('wheel', this._onWheel);\n    this.domElement.addEventListener('pointerdown', this._onPointerDown);\n    this.domElement.addEventListener('pointercancel', this._onPointerCancel);\n    window.addEventListener('resize', this._onWindowResize);\n  }\n  onSinglePanStart(event, operation) {\n    if (this.enabled) {\n      this.dispatchEvent(_startEvent);\n      this.setCenter(event.clientX, event.clientY);\n      switch (operation) {\n        case 'PAN':\n          if (!this.enablePan) {\n            return;\n          }\n          if (this._animationId != -1) {\n            cancelAnimationFrame(this._animationId);\n            this._animationId = -1;\n            this._timeStart = -1;\n            this.activateGizmos(false);\n            this.dispatchEvent(_changeEvent);\n          }\n          this.updateTbState(STATE.PAN, true);\n          this._startCursorPosition.copy(this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement));\n          if (this.enableGrid) {\n            this.drawGrid();\n            this.dispatchEvent(_changeEvent);\n          }\n          break;\n        case 'ROTATE':\n          if (!this.enableRotate) {\n            return;\n          }\n          if (this._animationId != -1) {\n            cancelAnimationFrame(this._animationId);\n            this._animationId = -1;\n            this._timeStart = -1;\n          }\n          this.updateTbState(STATE.ROTATE, true);\n          this._startCursorPosition.copy(this.unprojectOnTbSurface(this.camera, _center.x, _center.y, this.domElement, this._tbRadius));\n          this.activateGizmos(true);\n          if (this.enableAnimations) {\n            this._timePrev = this._timeCurrent = performance.now();\n            this._angleCurrent = this._anglePrev = 0;\n            this._cursorPosPrev.copy(this._startCursorPosition);\n            this._cursorPosCurr.copy(this._cursorPosPrev);\n            this._wCurr = 0;\n            this._wPrev = this._wCurr;\n          }\n          this.dispatchEvent(_changeEvent);\n          break;\n        case 'FOV':\n          if (!this.camera.isPerspectiveCamera || !this.enableZoom) {\n            return;\n          }\n          if (this._animationId != -1) {\n            cancelAnimationFrame(this._animationId);\n            this._animationId = -1;\n            this._timeStart = -1;\n            this.activateGizmos(false);\n            this.dispatchEvent(_changeEvent);\n          }\n          this.updateTbState(STATE.FOV, true);\n          this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n          this._currentCursorPosition.copy(this._startCursorPosition);\n          break;\n        case 'ZOOM':\n          if (!this.enableZoom) {\n            return;\n          }\n          if (this._animationId != -1) {\n            cancelAnimationFrame(this._animationId);\n            this._animationId = -1;\n            this._timeStart = -1;\n            this.activateGizmos(false);\n            this.dispatchEvent(_changeEvent);\n          }\n          this.updateTbState(STATE.SCALE, true);\n          this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n          this._currentCursorPosition.copy(this._startCursorPosition);\n          break;\n      }\n    }\n  }\n  onSinglePanMove(event, opState) {\n    if (this.enabled) {\n      const restart = opState != this._state;\n      this.setCenter(event.clientX, event.clientY);\n      switch (opState) {\n        case STATE.PAN:\n          if (this.enablePan) {\n            if (restart) {\n              //switch to pan operation\n\n              this.dispatchEvent(_endEvent);\n              this.dispatchEvent(_startEvent);\n              this.updateTbState(opState, true);\n              this._startCursorPosition.copy(this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement));\n              if (this.enableGrid) {\n                this.drawGrid();\n              }\n              this.activateGizmos(false);\n            } else {\n              //continue with pan operation\n              this._currentCursorPosition.copy(this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement));\n              this.applyTransformMatrix(this.pan(this._startCursorPosition, this._currentCursorPosition));\n            }\n          }\n          break;\n        case STATE.ROTATE:\n          if (this.enableRotate) {\n            if (restart) {\n              //switch to rotate operation\n\n              this.dispatchEvent(_endEvent);\n              this.dispatchEvent(_startEvent);\n              this.updateTbState(opState, true);\n              this._startCursorPosition.copy(this.unprojectOnTbSurface(this.camera, _center.x, _center.y, this.domElement, this._tbRadius));\n              if (this.enableGrid) {\n                this.disposeGrid();\n              }\n              this.activateGizmos(true);\n            } else {\n              //continue with rotate operation\n              this._currentCursorPosition.copy(this.unprojectOnTbSurface(this.camera, _center.x, _center.y, this.domElement, this._tbRadius));\n              const distance = this._startCursorPosition.distanceTo(this._currentCursorPosition);\n              const angle = this._startCursorPosition.angleTo(this._currentCursorPosition);\n              const amount = Math.max(distance / this._tbRadius, angle); //effective rotation angle\n\n              this.applyTransformMatrix(this.rotate(this.calculateRotationAxis(this._startCursorPosition, this._currentCursorPosition), amount));\n              if (this.enableAnimations) {\n                this._timePrev = this._timeCurrent;\n                this._timeCurrent = performance.now();\n                this._anglePrev = this._angleCurrent;\n                this._angleCurrent = amount;\n                this._cursorPosPrev.copy(this._cursorPosCurr);\n                this._cursorPosCurr.copy(this._currentCursorPosition);\n                this._wPrev = this._wCurr;\n                this._wCurr = this.calculateAngularSpeed(this._anglePrev, this._angleCurrent, this._timePrev, this._timeCurrent);\n              }\n            }\n          }\n          break;\n        case STATE.SCALE:\n          if (this.enableZoom) {\n            if (restart) {\n              //switch to zoom operation\n\n              this.dispatchEvent(_endEvent);\n              this.dispatchEvent(_startEvent);\n              this.updateTbState(opState, true);\n              this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n              this._currentCursorPosition.copy(this._startCursorPosition);\n              if (this.enableGrid) {\n                this.disposeGrid();\n              }\n              this.activateGizmos(false);\n            } else {\n              //continue with zoom operation\n              const screenNotches = 8; //how many wheel notches corresponds to a full screen pan\n              this._currentCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n              const movement = this._currentCursorPosition.y - this._startCursorPosition.y;\n              let size = 1;\n              if (movement < 0) {\n                size = 1 / Math.pow(this.scaleFactor, -movement * screenNotches);\n              } else if (movement > 0) {\n                size = Math.pow(this.scaleFactor, movement * screenNotches);\n              }\n              this._v3_1.setFromMatrixPosition(this._gizmoMatrixState);\n              this.applyTransformMatrix(this.scale(size, this._v3_1));\n            }\n          }\n          break;\n        case STATE.FOV:\n          if (this.enableZoom && this.camera.isPerspectiveCamera) {\n            if (restart) {\n              //switch to fov operation\n\n              this.dispatchEvent(_endEvent);\n              this.dispatchEvent(_startEvent);\n              this.updateTbState(opState, true);\n              this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n              this._currentCursorPosition.copy(this._startCursorPosition);\n              if (this.enableGrid) {\n                this.disposeGrid();\n              }\n              this.activateGizmos(false);\n            } else {\n              //continue with fov operation\n              const screenNotches = 8; //how many wheel notches corresponds to a full screen pan\n              this._currentCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n              const movement = this._currentCursorPosition.y - this._startCursorPosition.y;\n              let size = 1;\n              if (movement < 0) {\n                size = 1 / Math.pow(this.scaleFactor, -movement * screenNotches);\n              } else if (movement > 0) {\n                size = Math.pow(this.scaleFactor, movement * screenNotches);\n              }\n              this._v3_1.setFromMatrixPosition(this._cameraMatrixState);\n              const x = this._v3_1.distanceTo(this._gizmos.position);\n              let xNew = x / size; //distance between camera and gizmos if scale(size, scalepoint) would be performed\n\n              //check min and max distance\n              xNew = MathUtils.clamp(xNew, this.minDistance, this.maxDistance);\n              const y = x * Math.tan(MathUtils.DEG2RAD * this._fovState * 0.5);\n\n              //calculate new fov\n              let newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2);\n\n              //check min and max fov\n              newFov = MathUtils.clamp(newFov, this.minFov, this.maxFov);\n              const newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2));\n              size = x / newDistance;\n              this._v3_2.setFromMatrixPosition(this._gizmoMatrixState);\n              this.setFov(newFov);\n              this.applyTransformMatrix(this.scale(size, this._v3_2, false));\n\n              //adjusting distance\n              _offset.copy(this._gizmos.position).sub(this.camera.position).normalize().multiplyScalar(newDistance / x);\n              this._m4_1.makeTranslation(_offset.x, _offset.y, _offset.z);\n            }\n          }\n          break;\n      }\n      this.dispatchEvent(_changeEvent);\n    }\n  }\n  onSinglePanEnd() {\n    if (this._state == STATE.ROTATE) {\n      if (!this.enableRotate) {\n        return;\n      }\n      if (this.enableAnimations) {\n        //perform rotation animation\n        const deltaTime = performance.now() - this._timeCurrent;\n        if (deltaTime < 120) {\n          const w = Math.abs((this._wPrev + this._wCurr) / 2);\n          const self = this;\n          this._animationId = window.requestAnimationFrame(function (t) {\n            self.updateTbState(STATE.ANIMATION_ROTATE, true);\n            const rotationAxis = self.calculateRotationAxis(self._cursorPosPrev, self._cursorPosCurr);\n            self.onRotationAnim(t, rotationAxis, Math.min(w, self.wMax));\n          });\n        } else {\n          //cursor has been standing still for over 120 ms since last movement\n          this.updateTbState(STATE.IDLE, false);\n          this.activateGizmos(false);\n          this.dispatchEvent(_changeEvent);\n        }\n      } else {\n        this.updateTbState(STATE.IDLE, false);\n        this.activateGizmos(false);\n        this.dispatchEvent(_changeEvent);\n      }\n    } else if (this._state == STATE.PAN || this._state == STATE.IDLE) {\n      this.updateTbState(STATE.IDLE, false);\n      if (this.enableGrid) {\n        this.disposeGrid();\n      }\n      this.activateGizmos(false);\n      this.dispatchEvent(_changeEvent);\n    }\n    this.dispatchEvent(_endEvent);\n  }\n  onDoubleTap(event) {\n    if (this.enabled && this.enablePan && this.scene != null) {\n      this.dispatchEvent(_startEvent);\n      this.setCenter(event.clientX, event.clientY);\n      const hitP = this.unprojectOnObj(this.getCursorNDC(_center.x, _center.y, this.domElement), this.camera);\n      if (hitP != null && this.enableAnimations) {\n        const self = this;\n        if (this._animationId != -1) {\n          window.cancelAnimationFrame(this._animationId);\n        }\n        this._timeStart = -1;\n        this._animationId = window.requestAnimationFrame(function (t) {\n          self.updateTbState(STATE.ANIMATION_FOCUS, true);\n          self.onFocusAnim(t, hitP, self._cameraMatrixState, self._gizmoMatrixState);\n        });\n      } else if (hitP != null && !this.enableAnimations) {\n        this.updateTbState(STATE.FOCUS, true);\n        this.focus(hitP, this.scaleFactor);\n        this.updateTbState(STATE.IDLE, false);\n        this.dispatchEvent(_changeEvent);\n      }\n    }\n    this.dispatchEvent(_endEvent);\n  }\n  onDoublePanStart() {\n    if (this.enabled && this.enablePan) {\n      this.dispatchEvent(_startEvent);\n      this.updateTbState(STATE.PAN, true);\n      this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);\n      this._startCursorPosition.copy(this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement, true));\n      this._currentCursorPosition.copy(this._startCursorPosition);\n      this.activateGizmos(false);\n    }\n  }\n  onDoublePanMove() {\n    if (this.enabled && this.enablePan) {\n      this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);\n      if (this._state != STATE.PAN) {\n        this.updateTbState(STATE.PAN, true);\n        this._startCursorPosition.copy(this._currentCursorPosition);\n      }\n      this._currentCursorPosition.copy(this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement, true));\n      this.applyTransformMatrix(this.pan(this._startCursorPosition, this._currentCursorPosition, true));\n      this.dispatchEvent(_changeEvent);\n    }\n  }\n  onDoublePanEnd() {\n    this.updateTbState(STATE.IDLE, false);\n    this.dispatchEvent(_endEvent);\n  }\n  onRotateStart() {\n    if (this.enabled && this.enableRotate) {\n      this.dispatchEvent(_startEvent);\n      this.updateTbState(STATE.ZROTATE, true);\n\n      //this._startFingerRotation = event.rotation;\n\n      this._startFingerRotation = this.getAngle(this._touchCurrent[1], this._touchCurrent[0]) + this.getAngle(this._touchStart[1], this._touchStart[0]);\n      this._currentFingerRotation = this._startFingerRotation;\n      this.camera.getWorldDirection(this._rotationAxis); //rotation axis\n\n      if (!this.enablePan && !this.enableZoom) {\n        this.activateGizmos(true);\n      }\n    }\n  }\n  onRotateMove() {\n    if (this.enabled && this.enableRotate) {\n      this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);\n      let rotationPoint;\n      if (this._state != STATE.ZROTATE) {\n        this.updateTbState(STATE.ZROTATE, true);\n        this._startFingerRotation = this._currentFingerRotation;\n      }\n\n      //this._currentFingerRotation = event.rotation;\n      this._currentFingerRotation = this.getAngle(this._touchCurrent[1], this._touchCurrent[0]) + this.getAngle(this._touchStart[1], this._touchStart[0]);\n      if (!this.enablePan) {\n        rotationPoint = new Vector3().setFromMatrixPosition(this._gizmoMatrixState);\n      } else {\n        this._v3_2.setFromMatrixPosition(this._gizmoMatrixState);\n        rotationPoint = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement).applyQuaternion(this.camera.quaternion).multiplyScalar(1 / this.camera.zoom).add(this._v3_2);\n      }\n      const amount = MathUtils.DEG2RAD * (this._startFingerRotation - this._currentFingerRotation);\n      this.applyTransformMatrix(this.zRotate(rotationPoint, amount));\n      this.dispatchEvent(_changeEvent);\n    }\n  }\n  onRotateEnd() {\n    this.updateTbState(STATE.IDLE, false);\n    this.activateGizmos(false);\n    this.dispatchEvent(_endEvent);\n  }\n  onPinchStart() {\n    if (this.enabled && this.enableZoom) {\n      this.dispatchEvent(_startEvent);\n      this.updateTbState(STATE.SCALE, true);\n      this._startFingerDistance = this.calculatePointersDistance(this._touchCurrent[0], this._touchCurrent[1]);\n      this._currentFingerDistance = this._startFingerDistance;\n      this.activateGizmos(false);\n    }\n  }\n  onPinchMove() {\n    if (this.enabled && this.enableZoom) {\n      this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);\n      const minDistance = 12; //minimum distance between fingers (in css pixels)\n\n      if (this._state != STATE.SCALE) {\n        this._startFingerDistance = this._currentFingerDistance;\n        this.updateTbState(STATE.SCALE, true);\n      }\n      this._currentFingerDistance = Math.max(this.calculatePointersDistance(this._touchCurrent[0], this._touchCurrent[1]), minDistance * this._devPxRatio);\n      const amount = this._currentFingerDistance / this._startFingerDistance;\n      let scalePoint;\n      if (!this.enablePan) {\n        scalePoint = this._gizmos.position;\n      } else {\n        if (this.camera.isOrthographicCamera) {\n          scalePoint = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement).applyQuaternion(this.camera.quaternion).multiplyScalar(1 / this.camera.zoom).add(this._gizmos.position);\n        } else if (this.camera.isPerspectiveCamera) {\n          scalePoint = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement).applyQuaternion(this.camera.quaternion).add(this._gizmos.position);\n        }\n      }\n      this.applyTransformMatrix(this.scale(amount, scalePoint));\n      this.dispatchEvent(_changeEvent);\n    }\n  }\n  onPinchEnd() {\n    this.updateTbState(STATE.IDLE, false);\n    this.dispatchEvent(_endEvent);\n  }\n  onTriplePanStart() {\n    if (this.enabled && this.enableZoom) {\n      this.dispatchEvent(_startEvent);\n      this.updateTbState(STATE.SCALE, true);\n\n      //const center = event.center;\n      let clientX = 0;\n      let clientY = 0;\n      const nFingers = this._touchCurrent.length;\n      for (let i = 0; i < nFingers; i++) {\n        clientX += this._touchCurrent[i].clientX;\n        clientY += this._touchCurrent[i].clientY;\n      }\n      this.setCenter(clientX / nFingers, clientY / nFingers);\n      this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n      this._currentCursorPosition.copy(this._startCursorPosition);\n    }\n  }\n  onTriplePanMove() {\n    if (this.enabled && this.enableZoom) {\n      //\t  fov / 2\n      //\t\t|\\\n      //\t\t| \\\n      //\t\t|  \\\n      //\tx\t|\t\\\n      //\t\t| \t \\\n      //\t\t| \t  \\\n      //\t\t| _ _ _\\\n      //\t\t\ty\n\n      //const center = event.center;\n      let clientX = 0;\n      let clientY = 0;\n      const nFingers = this._touchCurrent.length;\n      for (let i = 0; i < nFingers; i++) {\n        clientX += this._touchCurrent[i].clientX;\n        clientY += this._touchCurrent[i].clientY;\n      }\n      this.setCenter(clientX / nFingers, clientY / nFingers);\n      const screenNotches = 8; //how many wheel notches corresponds to a full screen pan\n      this._currentCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n      const movement = this._currentCursorPosition.y - this._startCursorPosition.y;\n      let size = 1;\n      if (movement < 0) {\n        size = 1 / Math.pow(this.scaleFactor, -movement * screenNotches);\n      } else if (movement > 0) {\n        size = Math.pow(this.scaleFactor, movement * screenNotches);\n      }\n      this._v3_1.setFromMatrixPosition(this._cameraMatrixState);\n      const x = this._v3_1.distanceTo(this._gizmos.position);\n      let xNew = x / size; //distance between camera and gizmos if scale(size, scalepoint) would be performed\n\n      //check min and max distance\n      xNew = MathUtils.clamp(xNew, this.minDistance, this.maxDistance);\n      const y = x * Math.tan(MathUtils.DEG2RAD * this._fovState * 0.5);\n\n      //calculate new fov\n      let newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2);\n\n      //check min and max fov\n      newFov = MathUtils.clamp(newFov, this.minFov, this.maxFov);\n      const newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2));\n      size = x / newDistance;\n      this._v3_2.setFromMatrixPosition(this._gizmoMatrixState);\n      this.setFov(newFov);\n      this.applyTransformMatrix(this.scale(size, this._v3_2, false));\n\n      //adjusting distance\n      _offset.copy(this._gizmos.position).sub(this.camera.position).normalize().multiplyScalar(newDistance / x);\n      this._m4_1.makeTranslation(_offset.x, _offset.y, _offset.z);\n      this.dispatchEvent(_changeEvent);\n    }\n  }\n  onTriplePanEnd() {\n    this.updateTbState(STATE.IDLE, false);\n    this.dispatchEvent(_endEvent);\n    //this.dispatchEvent( _changeEvent );\n  }\n\n  /**\n   * Set _center's x/y coordinates\n   * @param {Number} clientX\n   * @param {Number} clientY\n   */\n  setCenter(clientX, clientY) {\n    _center.x = clientX;\n    _center.y = clientY;\n  }\n\n  /**\n   * Set default mouse actions\n   */\n  initializeMouseActions() {\n    this.setMouseAction('PAN', 0, 'CTRL');\n    this.setMouseAction('PAN', 2);\n    this.setMouseAction('ROTATE', 0);\n    this.setMouseAction('ZOOM', 'WHEEL');\n    this.setMouseAction('ZOOM', 1);\n    this.setMouseAction('FOV', 'WHEEL', 'SHIFT');\n    this.setMouseAction('FOV', 1, 'SHIFT');\n  }\n\n  /**\n   * Compare two mouse actions\n   * @param {Object} action1\n   * @param {Object} action2\n   * @returns {Boolean} True if action1 and action 2 are the same mouse action, false otherwise\n   */\n  compareMouseAction(action1, action2) {\n    if (action1.operation == action2.operation) {\n      if (action1.mouse == action2.mouse && action1.key == action2.key) {\n        return true;\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Set a new mouse action by specifying the operation to be performed and a mouse/key combination. In case of conflict, replaces the existing one\n   * @param {String} operation The operation to be performed ('PAN', 'ROTATE', 'ZOOM', 'FOV)\n   * @param {*} mouse A mouse button (0, 1, 2) or 'WHEEL' for wheel notches\n   * @param {*} key The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed\n   * @returns {Boolean} True if the mouse action has been successfully added, false otherwise\n   */\n  setMouseAction(operation, mouse, key = null) {\n    const operationInput = ['PAN', 'ROTATE', 'ZOOM', 'FOV'];\n    const mouseInput = [0, 1, 2, 'WHEEL'];\n    const keyInput = ['CTRL', 'SHIFT', null];\n    let state;\n    if (!operationInput.includes(operation) || !mouseInput.includes(mouse) || !keyInput.includes(key)) {\n      //invalid parameters\n      return false;\n    }\n    if (mouse == 'WHEEL') {\n      if (operation != 'ZOOM' && operation != 'FOV') {\n        //cannot associate 2D operation to 1D input\n        return false;\n      }\n    }\n    switch (operation) {\n      case 'PAN':\n        state = STATE.PAN;\n        break;\n      case 'ROTATE':\n        state = STATE.ROTATE;\n        break;\n      case 'ZOOM':\n        state = STATE.SCALE;\n        break;\n      case 'FOV':\n        state = STATE.FOV;\n        break;\n    }\n    const action = {\n      operation: operation,\n      mouse: mouse,\n      key: key,\n      state: state\n    };\n    for (let i = 0; i < this.mouseActions.length; i++) {\n      if (this.mouseActions[i].mouse == action.mouse && this.mouseActions[i].key == action.key) {\n        this.mouseActions.splice(i, 1, action);\n        return true;\n      }\n    }\n    this.mouseActions.push(action);\n    return true;\n  }\n\n  /**\n   * Remove a mouse action by specifying its mouse/key combination\n   * @param {*} mouse A mouse button (0, 1, 2) or 'WHEEL' for wheel notches\n   * @param {*} key The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed\n   * @returns {Boolean} True if the operation has been succesfully removed, false otherwise\n   */\n  unsetMouseAction(mouse, key = null) {\n    for (let i = 0; i < this.mouseActions.length; i++) {\n      if (this.mouseActions[i].mouse == mouse && this.mouseActions[i].key == key) {\n        this.mouseActions.splice(i, 1);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Return the operation associated to a mouse/keyboard combination\n   * @param {*} mouse A mouse button (0, 1, 2) or 'WHEEL' for wheel notches\n   * @param {*} key The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed\n   * @returns The operation if it has been found, null otherwise\n   */\n  getOpFromAction(mouse, key) {\n    let action;\n    for (let i = 0; i < this.mouseActions.length; i++) {\n      action = this.mouseActions[i];\n      if (action.mouse == mouse && action.key == key) {\n        return action.operation;\n      }\n    }\n    if (key != null) {\n      for (let i = 0; i < this.mouseActions.length; i++) {\n        action = this.mouseActions[i];\n        if (action.mouse == mouse && action.key == null) {\n          return action.operation;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Get the operation associated to mouse and key combination and returns the corresponding FSA state\n   * @param {Number} mouse Mouse button\n   * @param {String} key Keyboard modifier\n   * @returns The FSA state obtained from the operation associated to mouse/keyboard combination\n   */\n  getOpStateFromAction(mouse, key) {\n    let action;\n    for (let i = 0; i < this.mouseActions.length; i++) {\n      action = this.mouseActions[i];\n      if (action.mouse == mouse && action.key == key) {\n        return action.state;\n      }\n    }\n    if (key != null) {\n      for (let i = 0; i < this.mouseActions.length; i++) {\n        action = this.mouseActions[i];\n        if (action.mouse == mouse && action.key == null) {\n          return action.state;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Calculate the angle between two pointers\n   * @param {PointerEvent} p1\n   * @param {PointerEvent} p2\n   * @returns {Number} The angle between two pointers in degrees\n   */\n  getAngle(p1, p2) {\n    return Math.atan2(p2.clientY - p1.clientY, p2.clientX - p1.clientX) * 180 / Math.PI;\n  }\n\n  /**\n   * Update a PointerEvent inside current pointerevents array\n   * @param {PointerEvent} event\n   */\n  updateTouchEvent(event) {\n    for (let i = 0; i < this._touchCurrent.length; i++) {\n      if (this._touchCurrent[i].pointerId == event.pointerId) {\n        this._touchCurrent.splice(i, 1, event);\n        break;\n      }\n    }\n  }\n\n  /**\n   * Apply a transformation matrix, to the camera and gizmos\n   * @param {Object} transformation Object containing matrices to apply to camera and gizmos\n   */\n  applyTransformMatrix(transformation) {\n    if (transformation.camera != null) {\n      this._m4_1.copy(this._cameraMatrixState).premultiply(transformation.camera);\n      this._m4_1.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);\n      this.camera.updateMatrix();\n\n      //update camera up vector\n      if (this._state == STATE.ROTATE || this._state == STATE.ZROTATE || this._state == STATE.ANIMATION_ROTATE) {\n        this.camera.up.copy(this._upState).applyQuaternion(this.camera.quaternion);\n      }\n    }\n    if (transformation.gizmos != null) {\n      this._m4_1.copy(this._gizmoMatrixState).premultiply(transformation.gizmos);\n      this._m4_1.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n      this._gizmos.updateMatrix();\n    }\n    if (this._state == STATE.SCALE || this._state == STATE.FOCUS || this._state == STATE.ANIMATION_FOCUS) {\n      this._tbRadius = this.calculateTbRadius(this.camera);\n      if (this.adjustNearFar) {\n        const cameraDistance = this.camera.position.distanceTo(this._gizmos.position);\n        const bb = new Box3();\n        bb.setFromObject(this._gizmos);\n        const sphere = new Sphere();\n        bb.getBoundingSphere(sphere);\n        const adjustedNearPosition = Math.max(this._nearPos0, sphere.radius + sphere.center.length());\n        const regularNearPosition = cameraDistance - this._initialNear;\n        const minNearPos = Math.min(adjustedNearPosition, regularNearPosition);\n        this.camera.near = cameraDistance - minNearPos;\n        const adjustedFarPosition = Math.min(this._farPos0, -sphere.radius + sphere.center.length());\n        const regularFarPosition = cameraDistance - this._initialFar;\n        const minFarPos = Math.min(adjustedFarPosition, regularFarPosition);\n        this.camera.far = cameraDistance - minFarPos;\n        this.camera.updateProjectionMatrix();\n      } else {\n        let update = false;\n        if (this.camera.near != this._initialNear) {\n          this.camera.near = this._initialNear;\n          update = true;\n        }\n        if (this.camera.far != this._initialFar) {\n          this.camera.far = this._initialFar;\n          update = true;\n        }\n        if (update) {\n          this.camera.updateProjectionMatrix();\n        }\n      }\n    }\n  }\n\n  /**\n   * Calculate the angular speed\n   * @param {Number} p0 Position at t0\n   * @param {Number} p1 Position at t1\n   * @param {Number} t0 Initial time in milliseconds\n   * @param {Number} t1 Ending time in milliseconds\n   */\n  calculateAngularSpeed(p0, p1, t0, t1) {\n    const s = p1 - p0;\n    const t = (t1 - t0) / 1000;\n    if (t == 0) {\n      return 0;\n    }\n    return s / t;\n  }\n\n  /**\n   * Calculate the distance between two pointers\n   * @param {PointerEvent} p0 The first pointer\n   * @param {PointerEvent} p1 The second pointer\n   * @returns {number} The distance between the two pointers\n   */\n  calculatePointersDistance(p0, p1) {\n    return Math.sqrt(Math.pow(p1.clientX - p0.clientX, 2) + Math.pow(p1.clientY - p0.clientY, 2));\n  }\n\n  /**\n   * Calculate the rotation axis as the vector perpendicular between two vectors\n   * @param {Vector3} vec1 The first vector\n   * @param {Vector3} vec2 The second vector\n   * @returns {Vector3} The normalized rotation axis\n   */\n  calculateRotationAxis(vec1, vec2) {\n    this._rotationMatrix.extractRotation(this._cameraMatrixState);\n    this._quat.setFromRotationMatrix(this._rotationMatrix);\n    this._rotationAxis.crossVectors(vec1, vec2).applyQuaternion(this._quat);\n    return this._rotationAxis.normalize().clone();\n  }\n\n  /**\n   * Calculate the trackball radius so that gizmo's diamater will be 2/3 of the minimum side of the camera frustum\n   * @param {Camera} camera\n   * @returns {Number} The trackball radius\n   */\n  calculateTbRadius(camera) {\n    const distance = camera.position.distanceTo(this._gizmos.position);\n    if (camera.type == 'PerspectiveCamera') {\n      const halfFovV = MathUtils.DEG2RAD * camera.fov * 0.5; //vertical fov/2 in radians\n      const halfFovH = Math.atan(camera.aspect * Math.tan(halfFovV)); //horizontal fov/2 in radians\n      return Math.tan(Math.min(halfFovV, halfFovH)) * distance * this.radiusFactor;\n    } else if (camera.type == 'OrthographicCamera') {\n      return Math.min(camera.top, camera.right) * this.radiusFactor;\n    }\n  }\n\n  /**\n   * Focus operation consist of positioning the point of interest in front of the camera and a slightly zoom in\n   * @param {Vector3} point The point of interest\n   * @param {Number} size Scale factor\n   * @param {Number} amount Amount of operation to be completed (used for focus animations, default is complete full operation)\n   */\n  focus(point, size, amount = 1) {\n    //move center of camera (along with gizmos) towards point of interest\n    _offset.copy(point).sub(this._gizmos.position).multiplyScalar(amount);\n    this._translationMatrix.makeTranslation(_offset.x, _offset.y, _offset.z);\n    _gizmoMatrixStateTemp.copy(this._gizmoMatrixState);\n    this._gizmoMatrixState.premultiply(this._translationMatrix);\n    this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n    _cameraMatrixStateTemp.copy(this._cameraMatrixState);\n    this._cameraMatrixState.premultiply(this._translationMatrix);\n    this._cameraMatrixState.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);\n\n    //apply zoom\n    if (this.enableZoom) {\n      this.applyTransformMatrix(this.scale(size, this._gizmos.position));\n    }\n    this._gizmoMatrixState.copy(_gizmoMatrixStateTemp);\n    this._cameraMatrixState.copy(_cameraMatrixStateTemp);\n  }\n\n  /**\n   * Draw a grid and add it to the scene\n   */\n  drawGrid() {\n    if (this.scene != null) {\n      const color = 0x888888;\n      const multiplier = 3;\n      let size, divisions, maxLength, tick;\n      if (this.camera.isOrthographicCamera) {\n        const width = this.camera.right - this.camera.left;\n        const height = this.camera.bottom - this.camera.top;\n        maxLength = Math.max(width, height);\n        tick = maxLength / 20;\n        size = maxLength / this.camera.zoom * multiplier;\n        divisions = size / tick * this.camera.zoom;\n      } else if (this.camera.isPerspectiveCamera) {\n        const distance = this.camera.position.distanceTo(this._gizmos.position);\n        const halfFovV = MathUtils.DEG2RAD * this.camera.fov * 0.5;\n        const halfFovH = Math.atan(this.camera.aspect * Math.tan(halfFovV));\n        maxLength = Math.tan(Math.max(halfFovV, halfFovH)) * distance * 2;\n        tick = maxLength / 20;\n        size = maxLength * multiplier;\n        divisions = size / tick;\n      }\n      if (this._grid == null) {\n        this._grid = new GridHelper(size, divisions, color, color);\n        this._grid.position.copy(this._gizmos.position);\n        this._gridPosition.copy(this._grid.position);\n        this._grid.quaternion.copy(this.camera.quaternion);\n        this._grid.rotateX(Math.PI * 0.5);\n        this.scene.add(this._grid);\n      }\n    }\n  }\n\n  /**\n   * Remove all listeners, stop animations and clean scene\n   */\n  dispose() {\n    if (this._animationId != -1) {\n      window.cancelAnimationFrame(this._animationId);\n    }\n    this.domElement.removeEventListener('pointerdown', this._onPointerDown);\n    this.domElement.removeEventListener('pointercancel', this._onPointerCancel);\n    this.domElement.removeEventListener('wheel', this._onWheel);\n    this.domElement.removeEventListener('contextmenu', this._onContextMenu);\n    window.removeEventListener('pointermove', this._onPointerMove);\n    window.removeEventListener('pointerup', this._onPointerUp);\n    window.removeEventListener('resize', this._onWindowResize);\n    if (this.scene !== null) this.scene.remove(this._gizmos);\n    this.disposeGrid();\n  }\n\n  /**\n   * remove the grid from the scene\n   */\n  disposeGrid() {\n    if (this._grid != null && this.scene != null) {\n      this.scene.remove(this._grid);\n      this._grid = null;\n    }\n  }\n\n  /**\n   * Compute the easing out cubic function for ease out effect in animation\n   * @param {Number} t The absolute progress of the animation in the bound of 0 (beginning of the) and 1 (ending of animation)\n   * @returns {Number} Result of easing out cubic at time t\n   */\n  easeOutCubic(t) {\n    return 1 - Math.pow(1 - t, 3);\n  }\n\n  /**\n   * Make rotation gizmos more or less visible\n   * @param {Boolean} isActive If true, make gizmos more visible\n   */\n  activateGizmos(isActive) {\n    const gizmoX = this._gizmos.children[0];\n    const gizmoY = this._gizmos.children[1];\n    const gizmoZ = this._gizmos.children[2];\n    if (isActive) {\n      gizmoX.material.setValues({\n        opacity: 1\n      });\n      gizmoY.material.setValues({\n        opacity: 1\n      });\n      gizmoZ.material.setValues({\n        opacity: 1\n      });\n    } else {\n      gizmoX.material.setValues({\n        opacity: 0.6\n      });\n      gizmoY.material.setValues({\n        opacity: 0.6\n      });\n      gizmoZ.material.setValues({\n        opacity: 0.6\n      });\n    }\n  }\n\n  /**\n   * Calculate the cursor position in NDC\n   * @param {number} x Cursor horizontal coordinate within the canvas\n   * @param {number} y Cursor vertical coordinate within the canvas\n   * @param {HTMLElement} canvas The canvas where the renderer draws its output\n   * @returns {Vector2} Cursor normalized position inside the canvas\n   */\n  getCursorNDC(cursorX, cursorY, canvas) {\n    const canvasRect = canvas.getBoundingClientRect();\n    this._v2_1.setX((cursorX - canvasRect.left) / canvasRect.width * 2 - 1);\n    this._v2_1.setY((canvasRect.bottom - cursorY) / canvasRect.height * 2 - 1);\n    return this._v2_1.clone();\n  }\n\n  /**\n   * Calculate the cursor position inside the canvas x/y coordinates with the origin being in the center of the canvas\n   * @param {Number} x Cursor horizontal coordinate within the canvas\n   * @param {Number} y Cursor vertical coordinate within the canvas\n   * @param {HTMLElement} canvas The canvas where the renderer draws its output\n   * @returns {Vector2} Cursor position inside the canvas\n   */\n  getCursorPosition(cursorX, cursorY, canvas) {\n    this._v2_1.copy(this.getCursorNDC(cursorX, cursorY, canvas));\n    this._v2_1.x *= (this.camera.right - this.camera.left) * 0.5;\n    this._v2_1.y *= (this.camera.top - this.camera.bottom) * 0.5;\n    return this._v2_1.clone();\n  }\n\n  /**\n   * Set the camera to be controlled\n   * @param {Camera} camera The virtual camera to be controlled\n   */\n  setCamera(camera) {\n    camera.lookAt(this.target);\n    camera.updateMatrix();\n\n    //setting state\n    if (camera.type == 'PerspectiveCamera') {\n      this._fov0 = camera.fov;\n      this._fovState = camera.fov;\n    }\n    this._cameraMatrixState0.copy(camera.matrix);\n    this._cameraMatrixState.copy(this._cameraMatrixState0);\n    this._cameraProjectionState.copy(camera.projectionMatrix);\n    this._zoom0 = camera.zoom;\n    this._zoomState = this._zoom0;\n    this._initialNear = camera.near;\n    this._nearPos0 = camera.position.distanceTo(this.target) - camera.near;\n    this._nearPos = this._initialNear;\n    this._initialFar = camera.far;\n    this._farPos0 = camera.position.distanceTo(this.target) - camera.far;\n    this._farPos = this._initialFar;\n    this._up0.copy(camera.up);\n    this._upState.copy(camera.up);\n    this.camera = camera;\n    this.camera.updateProjectionMatrix();\n\n    //making gizmos\n    this._tbRadius = this.calculateTbRadius(camera);\n    this.makeGizmos(this.target, this._tbRadius);\n  }\n\n  /**\n   * Set gizmos visibility\n   * @param {Boolean} value Value of gizmos visibility\n   */\n  setGizmosVisible(value) {\n    this._gizmos.visible = value;\n    this.dispatchEvent(_changeEvent);\n  }\n\n  /**\n   * Set gizmos radius factor and redraws gizmos\n   * @param {Float} value Value of radius factor\n   */\n  setTbRadius(value) {\n    this.radiusFactor = value;\n    this._tbRadius = this.calculateTbRadius(this.camera);\n    const curve = new EllipseCurve(0, 0, this._tbRadius, this._tbRadius);\n    const points = curve.getPoints(this._curvePts);\n    const curveGeometry = new BufferGeometry().setFromPoints(points);\n    for (const gizmo in this._gizmos.children) {\n      this._gizmos.children[gizmo].geometry = curveGeometry;\n    }\n    this.dispatchEvent(_changeEvent);\n  }\n\n  /**\n   * Creates the rotation gizmos matching trackball center and radius\n   * @param {Vector3} tbCenter The trackball center\n   * @param {number} tbRadius The trackball radius\n   */\n  makeGizmos(tbCenter, tbRadius) {\n    const curve = new EllipseCurve(0, 0, tbRadius, tbRadius);\n    const points = curve.getPoints(this._curvePts);\n\n    //geometry\n    const curveGeometry = new BufferGeometry().setFromPoints(points);\n\n    //material\n    const curveMaterialX = new LineBasicMaterial({\n      color: 0xff8080,\n      fog: false,\n      transparent: true,\n      opacity: 0.6\n    });\n    const curveMaterialY = new LineBasicMaterial({\n      color: 0x80ff80,\n      fog: false,\n      transparent: true,\n      opacity: 0.6\n    });\n    const curveMaterialZ = new LineBasicMaterial({\n      color: 0x8080ff,\n      fog: false,\n      transparent: true,\n      opacity: 0.6\n    });\n\n    //line\n    const gizmoX = new Line(curveGeometry, curveMaterialX);\n    const gizmoY = new Line(curveGeometry, curveMaterialY);\n    const gizmoZ = new Line(curveGeometry, curveMaterialZ);\n    const rotation = Math.PI * 0.5;\n    gizmoX.rotation.x = rotation;\n    gizmoY.rotation.y = rotation;\n\n    //setting state\n    this._gizmoMatrixState0.identity().setPosition(tbCenter);\n    this._gizmoMatrixState.copy(this._gizmoMatrixState0);\n    if (this.camera.zoom !== 1) {\n      //adapt gizmos size to camera zoom\n      const size = 1 / this.camera.zoom;\n      this._scaleMatrix.makeScale(size, size, size);\n      this._translationMatrix.makeTranslation(-tbCenter.x, -tbCenter.y, -tbCenter.z);\n      this._gizmoMatrixState.premultiply(this._translationMatrix).premultiply(this._scaleMatrix);\n      this._translationMatrix.makeTranslation(tbCenter.x, tbCenter.y, tbCenter.z);\n      this._gizmoMatrixState.premultiply(this._translationMatrix);\n    }\n    this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n\n    //\n\n    this._gizmos.traverse(function (object) {\n      if (object.isLine) {\n        object.geometry.dispose();\n        object.material.dispose();\n      }\n    });\n    this._gizmos.clear();\n\n    //\n\n    this._gizmos.add(gizmoX);\n    this._gizmos.add(gizmoY);\n    this._gizmos.add(gizmoZ);\n  }\n\n  /**\n   * Perform animation for focus operation\n   * @param {Number} time Instant in which this function is called as performance.now()\n   * @param {Vector3} point Point of interest for focus operation\n   * @param {Matrix4} cameraMatrix Camera matrix\n   * @param {Matrix4} gizmoMatrix Gizmos matrix\n   */\n  onFocusAnim(time, point, cameraMatrix, gizmoMatrix) {\n    if (this._timeStart == -1) {\n      //animation start\n      this._timeStart = time;\n    }\n    if (this._state == STATE.ANIMATION_FOCUS) {\n      const deltaTime = time - this._timeStart;\n      const animTime = deltaTime / this.focusAnimationTime;\n      this._gizmoMatrixState.copy(gizmoMatrix);\n      if (animTime >= 1) {\n        //animation end\n\n        this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n        this.focus(point, this.scaleFactor);\n        this._timeStart = -1;\n        this.updateTbState(STATE.IDLE, false);\n        this.activateGizmos(false);\n        this.dispatchEvent(_changeEvent);\n      } else {\n        const amount = this.easeOutCubic(animTime);\n        const size = 1 - amount + this.scaleFactor * amount;\n        this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n        this.focus(point, size, amount);\n        this.dispatchEvent(_changeEvent);\n        const self = this;\n        this._animationId = window.requestAnimationFrame(function (t) {\n          self.onFocusAnim(t, point, cameraMatrix, gizmoMatrix.clone());\n        });\n      }\n    } else {\n      //interrupt animation\n\n      this._animationId = -1;\n      this._timeStart = -1;\n    }\n  }\n\n  /**\n   * Perform animation for rotation operation\n   * @param {Number} time Instant in which this function is called as performance.now()\n   * @param {Vector3} rotationAxis Rotation axis\n   * @param {number} w0 Initial angular velocity\n   */\n  onRotationAnim(time, rotationAxis, w0) {\n    if (this._timeStart == -1) {\n      //animation start\n      this._anglePrev = 0;\n      this._angleCurrent = 0;\n      this._timeStart = time;\n    }\n    if (this._state == STATE.ANIMATION_ROTATE) {\n      //w = w0 + alpha * t\n      const deltaTime = (time - this._timeStart) / 1000;\n      const w = w0 + -this.dampingFactor * deltaTime;\n      if (w > 0) {\n        //tetha = 0.5 * alpha * t^2 + w0 * t + tetha0\n        this._angleCurrent = 0.5 * -this.dampingFactor * Math.pow(deltaTime, 2) + w0 * deltaTime + 0;\n        this.applyTransformMatrix(this.rotate(rotationAxis, this._angleCurrent));\n        this.dispatchEvent(_changeEvent);\n        const self = this;\n        this._animationId = window.requestAnimationFrame(function (t) {\n          self.onRotationAnim(t, rotationAxis, w0);\n        });\n      } else {\n        this._animationId = -1;\n        this._timeStart = -1;\n        this.updateTbState(STATE.IDLE, false);\n        this.activateGizmos(false);\n        this.dispatchEvent(_changeEvent);\n      }\n    } else {\n      //interrupt animation\n\n      this._animationId = -1;\n      this._timeStart = -1;\n      if (this._state != STATE.ROTATE) {\n        this.activateGizmos(false);\n        this.dispatchEvent(_changeEvent);\n      }\n    }\n  }\n\n  /**\n   * Perform pan operation moving camera between two points\n   * @param {Vector3} p0 Initial point\n   * @param {Vector3} p1 Ending point\n   * @param {Boolean} adjust If movement should be adjusted considering camera distance (Perspective only)\n   */\n  pan(p0, p1, adjust = false) {\n    const movement = p0.clone().sub(p1);\n    if (this.camera.isOrthographicCamera) {\n      //adjust movement amount\n      movement.multiplyScalar(1 / this.camera.zoom);\n    } else if (this.camera.isPerspectiveCamera && adjust) {\n      //adjust movement amount\n      this._v3_1.setFromMatrixPosition(this._cameraMatrixState0); //camera's initial position\n      this._v3_2.setFromMatrixPosition(this._gizmoMatrixState0); //gizmo's initial position\n      const distanceFactor = this._v3_1.distanceTo(this._v3_2) / this.camera.position.distanceTo(this._gizmos.position);\n      movement.multiplyScalar(1 / distanceFactor);\n    }\n    this._v3_1.set(movement.x, movement.y, 0).applyQuaternion(this.camera.quaternion);\n    this._m4_1.makeTranslation(this._v3_1.x, this._v3_1.y, this._v3_1.z);\n    this.setTransformationMatrices(this._m4_1, this._m4_1);\n    return _transformation;\n  }\n\n  /**\n   * Reset trackball\n   */\n  reset() {\n    this.camera.zoom = this._zoom0;\n    if (this.camera.isPerspectiveCamera) {\n      this.camera.fov = this._fov0;\n    }\n    this.camera.near = this._nearPos;\n    this.camera.far = this._farPos;\n    this._cameraMatrixState.copy(this._cameraMatrixState0);\n    this._cameraMatrixState.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);\n    this.camera.up.copy(this._up0);\n    this.camera.updateMatrix();\n    this.camera.updateProjectionMatrix();\n    this._gizmoMatrixState.copy(this._gizmoMatrixState0);\n    this._gizmoMatrixState0.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n    this._gizmos.updateMatrix();\n    this._tbRadius = this.calculateTbRadius(this.camera);\n    this.makeGizmos(this._gizmos.position, this._tbRadius);\n    this.camera.lookAt(this._gizmos.position);\n    this.updateTbState(STATE.IDLE, false);\n    this.dispatchEvent(_changeEvent);\n  }\n\n  /**\n   * Rotate the camera around an axis passing by trackball's center\n   * @param {Vector3} axis Rotation axis\n   * @param {number} angle Angle in radians\n   * @returns {Object} Object with 'camera' field containing transformation matrix resulting from the operation to be applied to the camera\n   */\n  rotate(axis, angle) {\n    const point = this._gizmos.position; //rotation center\n    this._translationMatrix.makeTranslation(-point.x, -point.y, -point.z);\n    this._rotationMatrix.makeRotationAxis(axis, -angle);\n\n    //rotate camera\n    this._m4_1.makeTranslation(point.x, point.y, point.z);\n    this._m4_1.multiply(this._rotationMatrix);\n    this._m4_1.multiply(this._translationMatrix);\n    this.setTransformationMatrices(this._m4_1);\n    return _transformation;\n  }\n  copyState() {\n    let state;\n    if (this.camera.isOrthographicCamera) {\n      state = JSON.stringify({\n        arcballState: {\n          cameraFar: this.camera.far,\n          cameraMatrix: this.camera.matrix,\n          cameraNear: this.camera.near,\n          cameraUp: this.camera.up,\n          cameraZoom: this.camera.zoom,\n          gizmoMatrix: this._gizmos.matrix\n        }\n      });\n    } else if (this.camera.isPerspectiveCamera) {\n      state = JSON.stringify({\n        arcballState: {\n          cameraFar: this.camera.far,\n          cameraFov: this.camera.fov,\n          cameraMatrix: this.camera.matrix,\n          cameraNear: this.camera.near,\n          cameraUp: this.camera.up,\n          cameraZoom: this.camera.zoom,\n          gizmoMatrix: this._gizmos.matrix\n        }\n      });\n    }\n    navigator.clipboard.writeText(state);\n  }\n  pasteState() {\n    const self = this;\n    navigator.clipboard.readText().then(function resolved(value) {\n      self.setStateFromJSON(value);\n    });\n  }\n\n  /**\n   * Save the current state of the control. This can later be recover with .reset\n   */\n  saveState() {\n    this._cameraMatrixState0.copy(this.camera.matrix);\n    this._gizmoMatrixState0.copy(this._gizmos.matrix);\n    this._nearPos = this.camera.near;\n    this._farPos = this.camera.far;\n    this._zoom0 = this.camera.zoom;\n    this._up0.copy(this.camera.up);\n    if (this.camera.isPerspectiveCamera) {\n      this._fov0 = this.camera.fov;\n    }\n  }\n\n  /**\n   * Perform uniform scale operation around a given point\n   * @param {Number} size Scale factor\n   * @param {Vector3} point Point around which scale\n   * @param {Boolean} scaleGizmos If gizmos should be scaled (Perspective only)\n   * @returns {Object} Object with 'camera' and 'gizmo' fields containing transformation matrices resulting from the operation to be applied to the camera and gizmos\n   */\n  scale(size, point, scaleGizmos = true) {\n    _scalePointTemp.copy(point);\n    let sizeInverse = 1 / size;\n    if (this.camera.isOrthographicCamera) {\n      //camera zoom\n      this.camera.zoom = this._zoomState;\n      this.camera.zoom *= size;\n\n      //check min and max zoom\n      if (this.camera.zoom > this.maxZoom) {\n        this.camera.zoom = this.maxZoom;\n        sizeInverse = this._zoomState / this.maxZoom;\n      } else if (this.camera.zoom < this.minZoom) {\n        this.camera.zoom = this.minZoom;\n        sizeInverse = this._zoomState / this.minZoom;\n      }\n      this.camera.updateProjectionMatrix();\n      this._v3_1.setFromMatrixPosition(this._gizmoMatrixState); //gizmos position\n\n      //scale gizmos so they appear in the same spot having the same dimension\n      this._scaleMatrix.makeScale(sizeInverse, sizeInverse, sizeInverse);\n      this._translationMatrix.makeTranslation(-this._v3_1.x, -this._v3_1.y, -this._v3_1.z);\n      this._m4_2.makeTranslation(this._v3_1.x, this._v3_1.y, this._v3_1.z).multiply(this._scaleMatrix);\n      this._m4_2.multiply(this._translationMatrix);\n\n      //move camera and gizmos to obtain pinch effect\n      _scalePointTemp.sub(this._v3_1);\n      const amount = _scalePointTemp.clone().multiplyScalar(sizeInverse);\n      _scalePointTemp.sub(amount);\n      this._m4_1.makeTranslation(_scalePointTemp.x, _scalePointTemp.y, _scalePointTemp.z);\n      this._m4_2.premultiply(this._m4_1);\n      this.setTransformationMatrices(this._m4_1, this._m4_2);\n      return _transformation;\n    } else if (this.camera.isPerspectiveCamera) {\n      this._v3_1.setFromMatrixPosition(this._cameraMatrixState);\n      this._v3_2.setFromMatrixPosition(this._gizmoMatrixState);\n\n      //move camera\n      let distance = this._v3_1.distanceTo(_scalePointTemp);\n      let amount = distance - distance * sizeInverse;\n\n      //check min and max distance\n      const newDistance = distance - amount;\n      if (newDistance < this.minDistance) {\n        sizeInverse = this.minDistance / distance;\n        amount = distance - distance * sizeInverse;\n      } else if (newDistance > this.maxDistance) {\n        sizeInverse = this.maxDistance / distance;\n        amount = distance - distance * sizeInverse;\n      }\n      _offset.copy(_scalePointTemp).sub(this._v3_1).normalize().multiplyScalar(amount);\n      this._m4_1.makeTranslation(_offset.x, _offset.y, _offset.z);\n      if (scaleGizmos) {\n        //scale gizmos so they appear in the same spot having the same dimension\n        const pos = this._v3_2;\n        distance = pos.distanceTo(_scalePointTemp);\n        amount = distance - distance * sizeInverse;\n        _offset.copy(_scalePointTemp).sub(this._v3_2).normalize().multiplyScalar(amount);\n        this._translationMatrix.makeTranslation(pos.x, pos.y, pos.z);\n        this._scaleMatrix.makeScale(sizeInverse, sizeInverse, sizeInverse);\n        this._m4_2.makeTranslation(_offset.x, _offset.y, _offset.z).multiply(this._translationMatrix);\n        this._m4_2.multiply(this._scaleMatrix);\n        this._translationMatrix.makeTranslation(-pos.x, -pos.y, -pos.z);\n        this._m4_2.multiply(this._translationMatrix);\n        this.setTransformationMatrices(this._m4_1, this._m4_2);\n      } else {\n        this.setTransformationMatrices(this._m4_1);\n      }\n      return _transformation;\n    }\n  }\n\n  /**\n   * Set camera fov\n   * @param {Number} value fov to be setted\n   */\n  setFov(value) {\n    if (this.camera.isPerspectiveCamera) {\n      this.camera.fov = MathUtils.clamp(value, this.minFov, this.maxFov);\n      this.camera.updateProjectionMatrix();\n    }\n  }\n\n  /**\n   * Set values in transformation object\n   * @param {Matrix4} camera Transformation to be applied to the camera\n   * @param {Matrix4} gizmos Transformation to be applied to gizmos\n   */\n  setTransformationMatrices(camera = null, gizmos = null) {\n    if (camera != null) {\n      if (_transformation.camera != null) {\n        _transformation.camera.copy(camera);\n      } else {\n        _transformation.camera = camera.clone();\n      }\n    } else {\n      _transformation.camera = null;\n    }\n    if (gizmos != null) {\n      if (_transformation.gizmos != null) {\n        _transformation.gizmos.copy(gizmos);\n      } else {\n        _transformation.gizmos = gizmos.clone();\n      }\n    } else {\n      _transformation.gizmos = null;\n    }\n  }\n\n  /**\n   * Rotate camera around its direction axis passing by a given point by a given angle\n   * @param {Vector3} point The point where the rotation axis is passing trough\n   * @param {Number} angle Angle in radians\n   * @returns The computed transormation matix\n   */\n  zRotate(point, angle) {\n    this._rotationMatrix.makeRotationAxis(this._rotationAxis, angle);\n    this._translationMatrix.makeTranslation(-point.x, -point.y, -point.z);\n    this._m4_1.makeTranslation(point.x, point.y, point.z);\n    this._m4_1.multiply(this._rotationMatrix);\n    this._m4_1.multiply(this._translationMatrix);\n    this._v3_1.setFromMatrixPosition(this._gizmoMatrixState).sub(point); //vector from rotation center to gizmos position\n    this._v3_2.copy(this._v3_1).applyAxisAngle(this._rotationAxis, angle); //apply rotation\n    this._v3_2.sub(this._v3_1);\n    this._m4_2.makeTranslation(this._v3_2.x, this._v3_2.y, this._v3_2.z);\n    this.setTransformationMatrices(this._m4_1, this._m4_2);\n    return _transformation;\n  }\n  getRaycaster() {\n    return _raycaster;\n  }\n\n  /**\n   * Unproject the cursor on the 3D object surface\n   * @param {Vector2} cursor Cursor coordinates in NDC\n   * @param {Camera} camera Virtual camera\n   * @returns {Vector3} The point of intersection with the model, if exist, null otherwise\n   */\n  unprojectOnObj(cursor, camera) {\n    const raycaster = this.getRaycaster();\n    raycaster.near = camera.near;\n    raycaster.far = camera.far;\n    raycaster.setFromCamera(cursor, camera);\n    const intersect = raycaster.intersectObjects(this.scene.children, true);\n    for (let i = 0; i < intersect.length; i++) {\n      if (intersect[i].object.uuid != this._gizmos.uuid && intersect[i].face != null) {\n        return intersect[i].point.clone();\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Unproject the cursor on the trackball surface\n   * @param {Camera} camera The virtual camera\n   * @param {Number} cursorX Cursor horizontal coordinate on screen\n   * @param {Number} cursorY Cursor vertical coordinate on screen\n   * @param {HTMLElement} canvas The canvas where the renderer draws its output\n   * @param {number} tbRadius The trackball radius\n   * @returns {Vector3} The unprojected point on the trackball surface\n   */\n  unprojectOnTbSurface(camera, cursorX, cursorY, canvas, tbRadius) {\n    if (camera.type == 'OrthographicCamera') {\n      this._v2_1.copy(this.getCursorPosition(cursorX, cursorY, canvas));\n      this._v3_1.set(this._v2_1.x, this._v2_1.y, 0);\n      const x2 = Math.pow(this._v2_1.x, 2);\n      const y2 = Math.pow(this._v2_1.y, 2);\n      const r2 = Math.pow(this._tbRadius, 2);\n      if (x2 + y2 <= r2 * 0.5) {\n        //intersection with sphere\n        this._v3_1.setZ(Math.sqrt(r2 - (x2 + y2)));\n      } else {\n        //intersection with hyperboloid\n        this._v3_1.setZ(r2 * 0.5 / Math.sqrt(x2 + y2));\n      }\n      return this._v3_1;\n    } else if (camera.type == 'PerspectiveCamera') {\n      //unproject cursor on the near plane\n      this._v2_1.copy(this.getCursorNDC(cursorX, cursorY, canvas));\n      this._v3_1.set(this._v2_1.x, this._v2_1.y, -1);\n      this._v3_1.applyMatrix4(camera.projectionMatrixInverse);\n      const rayDir = this._v3_1.clone().normalize(); //unprojected ray direction\n      const cameraGizmoDistance = camera.position.distanceTo(this._gizmos.position);\n      const radius2 = Math.pow(tbRadius, 2);\n\n      //\t  camera\n      //\t\t|\\\n      //\t\t| \\\n      //\t\t|  \\\n      //\th\t|\t\\\n      //\t\t| \t \\\n      //\t\t| \t  \\\n      //\t_ _ | _ _ _\\ _ _  near plane\n      //\t\t\tl\n\n      const h = this._v3_1.z;\n      const l = Math.sqrt(Math.pow(this._v3_1.x, 2) + Math.pow(this._v3_1.y, 2));\n      if (l == 0) {\n        //ray aligned with camera\n        rayDir.set(this._v3_1.x, this._v3_1.y, tbRadius);\n        return rayDir;\n      }\n      const m = h / l;\n      const q = cameraGizmoDistance;\n\n      /*\n       * calculate intersection point between unprojected ray and trackball surface\n       *|y = m * x + q\n       *|x^2 + y^2 = r^2\n       *\n       * (m^2 + 1) * x^2 + (2 * m * q) * x + q^2 - r^2 = 0\n       */\n      let a = Math.pow(m, 2) + 1;\n      let b = 2 * m * q;\n      let c = Math.pow(q, 2) - radius2;\n      let delta = Math.pow(b, 2) - 4 * a * c;\n      if (delta >= 0) {\n        //intersection with sphere\n        this._v2_1.setX((-b - Math.sqrt(delta)) / (2 * a));\n        this._v2_1.setY(m * this._v2_1.x + q);\n        const angle = MathUtils.RAD2DEG * this._v2_1.angle();\n        if (angle >= 45) {\n          //if angle between intersection point and X' axis is >= 45°, return that point\n          //otherwise, calculate intersection point with hyperboloid\n\n          const rayLength = Math.sqrt(Math.pow(this._v2_1.x, 2) + Math.pow(cameraGizmoDistance - this._v2_1.y, 2));\n          rayDir.multiplyScalar(rayLength);\n          rayDir.z += cameraGizmoDistance;\n          return rayDir;\n        }\n      }\n\n      //intersection with hyperboloid\n      /*\n       *|y = m * x + q\n       *|y = (1 / x) * (r^2 / 2)\n       *\n       * m * x^2 + q * x - r^2 / 2 = 0\n       */\n\n      a = m;\n      b = q;\n      c = -radius2 * 0.5;\n      delta = Math.pow(b, 2) - 4 * a * c;\n      this._v2_1.setX((-b - Math.sqrt(delta)) / (2 * a));\n      this._v2_1.setY(m * this._v2_1.x + q);\n      const rayLength = Math.sqrt(Math.pow(this._v2_1.x, 2) + Math.pow(cameraGizmoDistance - this._v2_1.y, 2));\n      rayDir.multiplyScalar(rayLength);\n      rayDir.z += cameraGizmoDistance;\n      return rayDir;\n    }\n  }\n\n  /**\n   * Unproject the cursor on the plane passing through the center of the trackball orthogonal to the camera\n   * @param {Camera} camera The virtual camera\n   * @param {Number} cursorX Cursor horizontal coordinate on screen\n   * @param {Number} cursorY Cursor vertical coordinate on screen\n   * @param {HTMLElement} canvas The canvas where the renderer draws its output\n   * @param {Boolean} initialDistance If initial distance between camera and gizmos should be used for calculations instead of current (Perspective only)\n   * @returns {Vector3} The unprojected point on the trackball plane\n   */\n  unprojectOnTbPlane(camera, cursorX, cursorY, canvas, initialDistance = false) {\n    if (camera.type == 'OrthographicCamera') {\n      this._v2_1.copy(this.getCursorPosition(cursorX, cursorY, canvas));\n      this._v3_1.set(this._v2_1.x, this._v2_1.y, 0);\n      return this._v3_1.clone();\n    } else if (camera.type == 'PerspectiveCamera') {\n      this._v2_1.copy(this.getCursorNDC(cursorX, cursorY, canvas));\n\n      //unproject cursor on the near plane\n      this._v3_1.set(this._v2_1.x, this._v2_1.y, -1);\n      this._v3_1.applyMatrix4(camera.projectionMatrixInverse);\n      const rayDir = this._v3_1.clone().normalize(); //unprojected ray direction\n\n      //\t  camera\n      //\t\t|\\\n      //\t\t| \\\n      //\t\t|  \\\n      //\th\t|\t\\\n      //\t\t| \t \\\n      //\t\t| \t  \\\n      //\t_ _ | _ _ _\\ _ _  near plane\n      //\t\t\tl\n\n      const h = this._v3_1.z;\n      const l = Math.sqrt(Math.pow(this._v3_1.x, 2) + Math.pow(this._v3_1.y, 2));\n      let cameraGizmoDistance;\n      if (initialDistance) {\n        cameraGizmoDistance = this._v3_1.setFromMatrixPosition(this._cameraMatrixState0).distanceTo(this._v3_2.setFromMatrixPosition(this._gizmoMatrixState0));\n      } else {\n        cameraGizmoDistance = camera.position.distanceTo(this._gizmos.position);\n      }\n\n      /*\n       * calculate intersection point between unprojected ray and the plane\n       *|y = mx + q\n       *|y = 0\n       *\n       * x = -q/m\n      */\n      if (l == 0) {\n        //ray aligned with camera\n        rayDir.set(0, 0, 0);\n        return rayDir;\n      }\n      const m = h / l;\n      const q = cameraGizmoDistance;\n      const x = -q / m;\n      const rayLength = Math.sqrt(Math.pow(q, 2) + Math.pow(x, 2));\n      rayDir.multiplyScalar(rayLength);\n      rayDir.z = 0;\n      return rayDir;\n    }\n  }\n\n  /**\n   * Update camera and gizmos state\n   */\n  updateMatrixState() {\n    //update camera and gizmos state\n    this._cameraMatrixState.copy(this.camera.matrix);\n    this._gizmoMatrixState.copy(this._gizmos.matrix);\n    if (this.camera.isOrthographicCamera) {\n      this._cameraProjectionState.copy(this.camera.projectionMatrix);\n      this.camera.updateProjectionMatrix();\n      this._zoomState = this.camera.zoom;\n    } else if (this.camera.isPerspectiveCamera) {\n      this._fovState = this.camera.fov;\n    }\n  }\n\n  /**\n   * Update the trackball FSA\n   * @param {STATE} newState New state of the FSA\n   * @param {Boolean} updateMatrices If matriices state should be updated\n   */\n  updateTbState(newState, updateMatrices) {\n    this._state = newState;\n    if (updateMatrices) {\n      this.updateMatrixState();\n    }\n  }\n  update() {\n    const EPS = 0.000001;\n    if (this.target.equals(this._currentTarget) === false) {\n      this._gizmos.position.copy(this.target); //for correct radius calculation\n      this._tbRadius = this.calculateTbRadius(this.camera);\n      this.makeGizmos(this.target, this._tbRadius);\n      this._currentTarget.copy(this.target);\n    }\n\n    //check min/max parameters\n    if (this.camera.isOrthographicCamera) {\n      //check zoom\n      if (this.camera.zoom > this.maxZoom || this.camera.zoom < this.minZoom) {\n        const newZoom = MathUtils.clamp(this.camera.zoom, this.minZoom, this.maxZoom);\n        this.applyTransformMatrix(this.scale(newZoom / this.camera.zoom, this._gizmos.position, true));\n      }\n    } else if (this.camera.isPerspectiveCamera) {\n      //check distance\n      const distance = this.camera.position.distanceTo(this._gizmos.position);\n      if (distance > this.maxDistance + EPS || distance < this.minDistance - EPS) {\n        const newDistance = MathUtils.clamp(distance, this.minDistance, this.maxDistance);\n        this.applyTransformMatrix(this.scale(newDistance / distance, this._gizmos.position));\n        this.updateMatrixState();\n      }\n\n      //check fov\n      if (this.camera.fov < this.minFov || this.camera.fov > this.maxFov) {\n        this.camera.fov = MathUtils.clamp(this.camera.fov, this.minFov, this.maxFov);\n        this.camera.updateProjectionMatrix();\n      }\n      const oldRadius = this._tbRadius;\n      this._tbRadius = this.calculateTbRadius(this.camera);\n      if (oldRadius < this._tbRadius - EPS || oldRadius > this._tbRadius + EPS) {\n        const scale = (this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z) / 3;\n        const newRadius = this._tbRadius / scale;\n        const curve = new EllipseCurve(0, 0, newRadius, newRadius);\n        const points = curve.getPoints(this._curvePts);\n        const curveGeometry = new BufferGeometry().setFromPoints(points);\n        for (const gizmo in this._gizmos.children) {\n          this._gizmos.children[gizmo].geometry = curveGeometry;\n        }\n      }\n    }\n    this.camera.lookAt(this._gizmos.position);\n  }\n  setStateFromJSON(json) {\n    const state = JSON.parse(json);\n    if (state.arcballState != undefined) {\n      this._cameraMatrixState.fromArray(state.arcballState.cameraMatrix.elements);\n      this._cameraMatrixState.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);\n      this.camera.up.copy(state.arcballState.cameraUp);\n      this.camera.near = state.arcballState.cameraNear;\n      this.camera.far = state.arcballState.cameraFar;\n      this.camera.zoom = state.arcballState.cameraZoom;\n      if (this.camera.isPerspectiveCamera) {\n        this.camera.fov = state.arcballState.cameraFov;\n      }\n      this._gizmoMatrixState.fromArray(state.arcballState.gizmoMatrix.elements);\n      this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n      this.camera.updateMatrix();\n      this.camera.updateProjectionMatrix();\n      this._gizmos.updateMatrix();\n      this._tbRadius = this.calculateTbRadius(this.camera);\n      const gizmoTmp = new Matrix4().copy(this._gizmoMatrixState0);\n      this.makeGizmos(this._gizmos.position, this._tbRadius);\n      this._gizmoMatrixState0.copy(gizmoTmp);\n      this.camera.lookAt(this._gizmos.position);\n      this.updateTbState(STATE.IDLE, false);\n      this.dispatchEvent(_changeEvent);\n    }\n  }\n}\n\n//listeners\n\nfunction onWindowResize() {\n  const scale = (this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z) / 3;\n  this._tbRadius = this.calculateTbRadius(this.camera);\n  const newRadius = this._tbRadius / scale;\n  const curve = new EllipseCurve(0, 0, newRadius, newRadius);\n  const points = curve.getPoints(this._curvePts);\n  const curveGeometry = new BufferGeometry().setFromPoints(points);\n  for (const gizmo in this._gizmos.children) {\n    this._gizmos.children[gizmo].geometry = curveGeometry;\n  }\n  this.dispatchEvent(_changeEvent);\n}\nfunction onContextMenu(event) {\n  if (!this.enabled) {\n    return;\n  }\n  for (let i = 0; i < this.mouseActions.length; i++) {\n    if (this.mouseActions[i].mouse == 2) {\n      //prevent only if button 2 is actually used\n      event.preventDefault();\n      break;\n    }\n  }\n}\nfunction onPointerCancel() {\n  this._touchStart.splice(0, this._touchStart.length);\n  this._touchCurrent.splice(0, this._touchCurrent.length);\n  this._input = INPUT.NONE;\n}\nfunction onPointerDown(event) {}\nfunction onPointerDownWrap(event) {\n  var centerX = domElement.clientWidth / 2;\n  var centerY = domElement.clientHeight / 2;\n  const dx = event.clientX - centerX;\n  const dy = event.clientY - centerY;\n  const distance = Math.sqrt(dx * dx + dy * dy);\n  if (event.button == 0 && event.isPrimary) {\n    this._downValid = true;\n    this._downEvents.push(event);\n    this._downStart = performance.now();\n  } else {\n    this._downValid = false;\n  }\n  if (event.pointerType == 'touch' && this._input != INPUT.CURSOR) {\n    this._touchStart.push(event);\n    this._touchCurrent.push(event);\n    switch (this._input) {\n      case INPUT.NONE:\n        //singleStart\n        this._input = INPUT.ONE_FINGER;\n        this.onSinglePanStart(event, 'ROTATE');\n        window.addEventListener('pointermove', this._onPointerMove);\n        window.addEventListener('pointerup', this._onPointerUp);\n        break;\n      case INPUT.ONE_FINGER:\n      case INPUT.ONE_FINGER_SWITCHED:\n        //doubleStart\n        this._input = INPUT.TWO_FINGER;\n        this.onRotateStart();\n        this.onPinchStart();\n        this.onDoublePanStart();\n        break;\n      case INPUT.TWO_FINGER:\n        //multipleStart\n        this._input = INPUT.MULT_FINGER;\n        this.onTriplePanStart(event);\n        break;\n    }\n  } else if (event.pointerType != 'touch' && this._input == INPUT.NONE) {\n    let modifier = null;\n    if (event.ctrlKey || event.metaKey) {\n      modifier = 'CTRL';\n    } else if (event.shiftKey) {\n      modifier = 'SHIFT';\n    }\n    this._mouseOp = this.getOpFromAction(event.button, modifier);\n    if (this._mouseOp != null) {\n      window.addEventListener('pointermove', this._onPointerMove);\n      window.addEventListener('pointerup', this._onPointerUp);\n\n      //singleStart\n      this._input = INPUT.CURSOR;\n      this._button = event.button;\n      this.onSinglePanStart(event, this._mouseOp);\n    }\n  }\n}\nfunction onPointerMove(event) {\n  if (event.pointerType == 'touch' && this._input != INPUT.CURSOR) {\n    switch (this._input) {\n      case INPUT.ONE_FINGER:\n        //singleMove\n        this.updateTouchEvent(event);\n        this.onSinglePanMove(event, STATE.ROTATE);\n        break;\n      case INPUT.ONE_FINGER_SWITCHED:\n        const movement = this.calculatePointersDistance(this._touchCurrent[0], event) * this._devPxRatio;\n        if (movement >= this._switchSensibility) {\n          //singleMove\n          this._input = INPUT.ONE_FINGER;\n          this.updateTouchEvent(event);\n          this.onSinglePanStart(event, 'ROTATE');\n          break;\n        }\n        break;\n      case INPUT.TWO_FINGER:\n        //rotate/pan/pinchMove\n        this.updateTouchEvent(event);\n        this.onRotateMove();\n        this.onPinchMove();\n        this.onDoublePanMove();\n        break;\n      case INPUT.MULT_FINGER:\n        //multMove\n        this.updateTouchEvent(event);\n        this.onTriplePanMove(event);\n        break;\n    }\n  } else if (event.pointerType != 'touch' && this._input == INPUT.CURSOR) {\n    let modifier = null;\n    if (event.ctrlKey || event.metaKey) {\n      modifier = 'CTRL';\n    } else if (event.shiftKey) {\n      modifier = 'SHIFT';\n    }\n    const mouseOpState = this.getOpStateFromAction(this._button, modifier);\n    if (mouseOpState != null) {\n      this.onSinglePanMove(event, mouseOpState);\n    }\n  }\n\n  //checkDistance\n  if (this._downValid) {\n    const movement = this.calculatePointersDistance(this._downEvents[this._downEvents.length - 1], event) * this._devPxRatio;\n    if (movement > this._movementThreshold) {\n      this._downValid = false;\n    }\n  }\n}\nfunction onPointerUp(event) {\n  if (event.pointerType == 'touch' && this._input != INPUT.CURSOR) {\n    const nTouch = this._touchCurrent.length;\n    for (let i = 0; i < nTouch; i++) {\n      if (this._touchCurrent[i].pointerId == event.pointerId) {\n        this._touchCurrent.splice(i, 1);\n        this._touchStart.splice(i, 1);\n        break;\n      }\n    }\n    switch (this._input) {\n      case INPUT.ONE_FINGER:\n      case INPUT.ONE_FINGER_SWITCHED:\n        //singleEnd\n        window.removeEventListener('pointermove', this._onPointerMove);\n        window.removeEventListener('pointerup', this._onPointerUp);\n        this._input = INPUT.NONE;\n        this.onSinglePanEnd();\n        break;\n      case INPUT.TWO_FINGER:\n        //doubleEnd\n        this.onDoublePanEnd(event);\n        this.onPinchEnd(event);\n        this.onRotateEnd(event);\n\n        //switching to singleStart\n        this._input = INPUT.ONE_FINGER_SWITCHED;\n        break;\n      case INPUT.MULT_FINGER:\n        if (this._touchCurrent.length == 0) {\n          window.removeEventListener('pointermove', this._onPointerMove);\n          window.removeEventListener('pointerup', this._onPointerUp);\n\n          //multCancel\n          this._input = INPUT.NONE;\n          this.onTriplePanEnd();\n        }\n        break;\n    }\n  } else if (event.pointerType != 'touch' && this._input == INPUT.CURSOR) {\n    window.removeEventListener('pointermove', this._onPointerMove);\n    window.removeEventListener('pointerup', this._onPointerUp);\n    this._input = INPUT.NONE;\n    this.onSinglePanEnd();\n    this._button = -1;\n  }\n  if (event.isPrimary) {\n    if (this._downValid) {\n      const downTime = event.timeStamp - this._downEvents[this._downEvents.length - 1].timeStamp;\n      if (downTime <= this._maxDownTime) {\n        if (this._nclicks == 0) {\n          //first valid click detected\n          this._nclicks = 1;\n          this._clickStart = performance.now();\n        } else {\n          const clickInterval = event.timeStamp - this._clickStart;\n          const movement = this.calculatePointersDistance(this._downEvents[1], this._downEvents[0]) * this._devPxRatio;\n          if (clickInterval <= this._maxInterval && movement <= this._posThreshold) {\n            //second valid click detected\n            //fire double tap and reset values\n            this._nclicks = 0;\n            this._downEvents.splice(0, this._downEvents.length);\n            this.onDoubleTap(event);\n          } else {\n            //new 'first click'\n            this._nclicks = 1;\n            this._downEvents.shift();\n            this._clickStart = performance.now();\n          }\n        }\n      } else {\n        this._downValid = false;\n        this._nclicks = 0;\n        this._downEvents.splice(0, this._downEvents.length);\n      }\n    } else {\n      this._nclicks = 0;\n      this._downEvents.splice(0, this._downEvents.length);\n    }\n  }\n}\nfunction onWheel(event) {\n  if (this.enabled && this.enableZoom) {\n    let modifier = null;\n    if (event.ctrlKey || event.metaKey) {\n      modifier = 'CTRL';\n    } else if (event.shiftKey) {\n      modifier = 'SHIFT';\n    }\n    const mouseOp = this.getOpFromAction('WHEEL', modifier);\n    if (mouseOp != null) {\n      event.preventDefault();\n      this.dispatchEvent(_startEvent);\n      const notchDeltaY = 125; //distance of one notch of mouse wheel\n      let sgn = event.deltaY / notchDeltaY;\n      let size = 1;\n      if (sgn > 0) {\n        size = 1 / this.scaleFactor;\n      } else if (sgn < 0) {\n        size = this.scaleFactor;\n      }\n      switch (mouseOp) {\n        case 'ZOOM':\n          this.updateTbState(STATE.SCALE, true);\n          if (sgn > 0) {\n            size = 1 / Math.pow(this.scaleFactor, sgn);\n          } else if (sgn < 0) {\n            size = Math.pow(this.scaleFactor, -sgn);\n          }\n          if (this.cursorZoom && this.enablePan) {\n            let scalePoint;\n            if (this.camera.isOrthographicCamera) {\n              scalePoint = this.unprojectOnTbPlane(this.camera, event.clientX, event.clientY, this.domElement).applyQuaternion(this.camera.quaternion).multiplyScalar(1 / this.camera.zoom).add(this._gizmos.position);\n            } else if (this.camera.isPerspectiveCamera) {\n              scalePoint = this.unprojectOnTbPlane(this.camera, event.clientX, event.clientY, this.domElement).applyQuaternion(this.camera.quaternion).add(this._gizmos.position);\n            }\n            this.applyTransformMatrix(this.scale(size, scalePoint));\n          } else {\n            this.applyTransformMatrix(this.scale(size, this._gizmos.position));\n          }\n          if (this._grid != null) {\n            this.disposeGrid();\n            this.drawGrid();\n          }\n          this.updateTbState(STATE.IDLE, false);\n          this.dispatchEvent(_changeEvent);\n          this.dispatchEvent(_endEvent);\n          break;\n        case 'FOV':\n          if (this.camera.isPerspectiveCamera) {\n            this.updateTbState(STATE.FOV, true);\n\n            //Vertigo effect\n\n            //\t  fov / 2\n            //\t\t|\\\n            //\t\t| \\\n            //\t\t|  \\\n            //\tx\t|\t\\\n            //\t\t| \t \\\n            //\t\t| \t  \\\n            //\t\t| _ _ _\\\n            //\t\t\ty\n\n            //check for iOs shift shortcut\n            if (event.deltaX != 0) {\n              sgn = event.deltaX / notchDeltaY;\n              size = 1;\n              if (sgn > 0) {\n                size = 1 / Math.pow(this.scaleFactor, sgn);\n              } else if (sgn < 0) {\n                size = Math.pow(this.scaleFactor, -sgn);\n              }\n            }\n            this._v3_1.setFromMatrixPosition(this._cameraMatrixState);\n            const x = this._v3_1.distanceTo(this._gizmos.position);\n            let xNew = x / size; //distance between camera and gizmos if scale(size, scalepoint) would be performed\n\n            //check min and max distance\n            xNew = MathUtils.clamp(xNew, this.minDistance, this.maxDistance);\n            const y = x * Math.tan(MathUtils.DEG2RAD * this.camera.fov * 0.5);\n\n            //calculate new fov\n            let newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2);\n\n            //check min and max fov\n            if (newFov > this.maxFov) {\n              newFov = this.maxFov;\n            } else if (newFov < this.minFov) {\n              newFov = this.minFov;\n            }\n            const newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2));\n            size = x / newDistance;\n            this.setFov(newFov);\n            this.applyTransformMatrix(this.scale(size, this._gizmos.position, false));\n          }\n          if (this._grid != null) {\n            this.disposeGrid();\n            this.drawGrid();\n          }\n          this.updateTbState(STATE.IDLE, false);\n          this.dispatchEvent(_changeEvent);\n          this.dispatchEvent(_endEvent);\n          break;\n      }\n    }\n  }\n}\nexport { ArcballControls };","map":{"version":3,"names":["GridHelper","EllipseCurve","BufferGeometry","Line","LineBasicMaterial","Raycaster","Group","Box3","Sphere","Quaternion","Vector2","Vector3","Matrix4","MathUtils","EventDispatcher","STATE","IDLE","Symbol","ROTATE","PAN","SCALE","FOV","FOCUS","ZROTATE","TOUCH_MULTI","ANIMATION_FOCUS","ANIMATION_ROTATE","INPUT","NONE","ONE_FINGER","ONE_FINGER_SWITCHED","TWO_FINGER","MULT_FINGER","CURSOR","_center","x","y","_transformation","camera","gizmos","_changeEvent","type","_startEvent","_endEvent","_raycaster","_offset","_gizmoMatrixStateTemp","_cameraMatrixStateTemp","_scalePointTemp","ArcballControls","constructor","domElement","scene","target","_currentTarget","radiusFactor","mouseActions","_mouseOp","_v2_1","_v3_1","_v3_2","_m4_1","_m4_2","_quat","_translationMatrix","_rotationMatrix","_scaleMatrix","_rotationAxis","_cameraMatrixState","_cameraProjectionState","_fovState","_upState","_zoomState","_nearPos","_farPos","_gizmoMatrixState","_up0","_zoom0","_fov0","_initialNear","_nearPos0","_initialFar","_farPos0","_cameraMatrixState0","_gizmoMatrixState0","_button","_touchStart","_touchCurrent","_input","_switchSensibility","_startFingerDistance","_currentFingerDistance","_startFingerRotation","_currentFingerRotation","_devPxRatio","_downValid","_nclicks","_downEvents","_downStart","_clickStart","_maxDownTime","_maxInterval","_posThreshold","_movementThreshold","_currentCursorPosition","_startCursorPosition","_grid","_gridPosition","_gizmos","_curvePts","_timeStart","_animationId","focusAnimationTime","_timePrev","_timeCurrent","_anglePrev","_angleCurrent","_cursorPosPrev","_cursorPosCurr","_wPrev","_wCurr","adjustNearFar","scaleFactor","dampingFactor","wMax","enableAnimations","enableGrid","cursorZoom","minFov","maxFov","enabled","enablePan","enableRotate","enableZoom","enableGizmos","minDistance","maxDistance","Infinity","minZoom","maxZoom","_tbRadius","_state","setCamera","add","style","touchAction","window","devicePixelRatio","initializeMouseActions","_onContextMenu","onContextMenu","bind","_onWheel","onWheel","_onPointerUp","onPointerUp","_onPointerMove","onPointerMove","_onPointerDown","onPointerDown","_onPointerCancel","onPointerCancel","_onWindowResize","onWindowResize","addEventListener","onSinglePanStart","event","operation","dispatchEvent","setCenter","clientX","clientY","cancelAnimationFrame","activateGizmos","updateTbState","copy","unprojectOnTbPlane","drawGrid","unprojectOnTbSurface","performance","now","isPerspectiveCamera","setY","getCursorNDC","onSinglePanMove","opState","restart","applyTransformMatrix","pan","disposeGrid","distance","distanceTo","angle","angleTo","amount","Math","max","rotate","calculateRotationAxis","calculateAngularSpeed","screenNotches","movement","size","pow","setFromMatrixPosition","scale","position","xNew","clamp","tan","DEG2RAD","newFov","RAD2DEG","atan","newDistance","setFov","sub","normalize","multiplyScalar","makeTranslation","z","onSinglePanEnd","deltaTime","w","abs","self","requestAnimationFrame","t","rotationAxis","onRotationAnim","min","onDoubleTap","hitP","unprojectOnObj","onFocusAnim","focus","onDoublePanStart","onDoublePanMove","onDoublePanEnd","onRotateStart","getAngle","getWorldDirection","onRotateMove","rotationPoint","applyQuaternion","quaternion","zoom","zRotate","onRotateEnd","onPinchStart","calculatePointersDistance","onPinchMove","scalePoint","isOrthographicCamera","onPinchEnd","onTriplePanStart","nFingers","length","i","onTriplePanMove","onTriplePanEnd","setMouseAction","compareMouseAction","action1","action2","mouse","key","operationInput","mouseInput","keyInput","state","includes","action","splice","push","unsetMouseAction","getOpFromAction","getOpStateFromAction","p1","p2","atan2","PI","updateTouchEvent","pointerId","transformation","premultiply","decompose","updateMatrix","up","calculateTbRadius","cameraDistance","bb","setFromObject","sphere","getBoundingSphere","adjustedNearPosition","radius","center","regularNearPosition","minNearPos","near","adjustedFarPosition","regularFarPosition","minFarPos","far","updateProjectionMatrix","update","p0","t0","t1","s","sqrt","vec1","vec2","extractRotation","setFromRotationMatrix","crossVectors","clone","halfFovV","fov","halfFovH","aspect","top","right","point","color","multiplier","divisions","maxLength","tick","width","left","height","bottom","rotateX","dispose","removeEventListener","remove","easeOutCubic","isActive","gizmoX","children","gizmoY","gizmoZ","material","setValues","opacity","cursorX","cursorY","canvas","canvasRect","getBoundingClientRect","setX","getCursorPosition","lookAt","matrix","projectionMatrix","makeGizmos","setGizmosVisible","value","visible","setTbRadius","curve","points","getPoints","curveGeometry","setFromPoints","gizmo","geometry","tbCenter","tbRadius","curveMaterialX","fog","transparent","curveMaterialY","curveMaterialZ","rotation","identity","setPosition","makeScale","traverse","object","isLine","clear","time","cameraMatrix","gizmoMatrix","animTime","w0","adjust","distanceFactor","set","setTransformationMatrices","reset","axis","makeRotationAxis","multiply","copyState","JSON","stringify","arcballState","cameraFar","cameraNear","cameraUp","cameraZoom","cameraFov","navigator","clipboard","writeText","pasteState","readText","then","resolved","setStateFromJSON","saveState","scaleGizmos","sizeInverse","pos","applyAxisAngle","getRaycaster","cursor","raycaster","setFromCamera","intersect","intersectObjects","uuid","face","x2","y2","r2","setZ","applyMatrix4","projectionMatrixInverse","rayDir","cameraGizmoDistance","radius2","h","l","m","q","a","b","c","delta","rayLength","initialDistance","updateMatrixState","newState","updateMatrices","EPS","equals","newZoom","oldRadius","newRadius","json","parse","undefined","fromArray","elements","gizmoTmp","preventDefault","onPointerDownWrap","centerX","clientWidth","centerY","clientHeight","dx","dy","button","isPrimary","pointerType","modifier","ctrlKey","metaKey","shiftKey","mouseOpState","nTouch","downTime","timeStamp","clickInterval","shift","mouseOp","notchDeltaY","sgn","deltaY","deltaX"],"sources":["/Users/olliearrison/Desktop/SURA/src/assets/js/ArcballControls.js"],"sourcesContent":["/* eslint-disable */\n\nimport {\n\tGridHelper,\n\tEllipseCurve,\n\tBufferGeometry,\n\tLine,\n\tLineBasicMaterial,\n\tRaycaster,\n\tGroup,\n\tBox3,\n\tSphere,\n\tQuaternion,\n\tVector2,\n\tVector3,\n\tMatrix4,\n\tMathUtils,\n\tEventDispatcher\n} from 'three';\n\n//trackball state\nconst STATE = {\n\n\tIDLE: Symbol(),\n\tROTATE: Symbol(),\n\tPAN: Symbol(),\n\tSCALE: Symbol(),\n\tFOV: Symbol(),\n\tFOCUS: Symbol(),\n\tZROTATE: Symbol(),\n\tTOUCH_MULTI: Symbol(),\n\tANIMATION_FOCUS: Symbol(),\n\tANIMATION_ROTATE: Symbol()\n\n};\n\nconst INPUT = {\n\n\tNONE: Symbol(),\n\tONE_FINGER: Symbol(),\n\tONE_FINGER_SWITCHED: Symbol(),\n\tTWO_FINGER: Symbol(),\n\tMULT_FINGER: Symbol(),\n\tCURSOR: Symbol()\n\n};\n\n//cursor center coordinates\nconst _center = {\n\n\tx: 0,\n\ty: 0\n\n};\n\n//transformation matrices for gizmos and camera\nconst _transformation = {\n\n\tcamera: new Matrix4(),\n\tgizmos: new Matrix4()\n\n};\n\n//events\nconst _changeEvent = { type: 'change' };\nconst _startEvent = { type: 'start' };\nconst _endEvent = { type: 'end' };\n\nconst _raycaster = new Raycaster();\nconst _offset = new Vector3();\n\nconst _gizmoMatrixStateTemp = new Matrix4();\nconst _cameraMatrixStateTemp = new Matrix4();\nconst _scalePointTemp = new Vector3();\n/**\n *\n * @param {Camera} camera Virtual camera used in the scene\n * @param {HTMLElement} domElement Renderer's dom element\n * @param {Scene} scene The scene to be rendered\n */\nclass ArcballControls extends EventDispatcher {\n\n\tconstructor( camera, domElement, scene = null ) {\n\n\t\tsuper();\n\t\tthis.camera = null;\n\t\tthis.domElement = domElement;\n\t\tthis.scene = scene;\n\t\tthis.target = new Vector3();\n\t\tthis._currentTarget = new Vector3();\n\t\tthis.radiusFactor = 0.67;\n\n\t\tthis.mouseActions = [];\n\t\tthis._mouseOp = null;\n\n\n\t\t//global vectors and matrices that are used in some operations to avoid creating new objects every time (e.g. every time cursor moves)\n\t\tthis._v2_1 = new Vector2();\n\t\tthis._v3_1 = new Vector3();\n\t\tthis._v3_2 = new Vector3();\n\n\t\tthis._m4_1 = new Matrix4();\n\t\tthis._m4_2 = new Matrix4();\n\n\t\tthis._quat = new Quaternion();\n\n\t\t//transformation matrices\n\t\tthis._translationMatrix = new Matrix4(); //matrix for translation operation\n\t\tthis._rotationMatrix = new Matrix4(); //matrix for rotation operation\n\t\tthis._scaleMatrix = new Matrix4(); //matrix for scaling operation\n\n\t\tthis._rotationAxis = new Vector3(); //axis for rotate operation\n\n\n\t\t//camera state\n\t\tthis._cameraMatrixState = new Matrix4();\n\t\tthis._cameraProjectionState = new Matrix4();\n\n\t\tthis._fovState = 1;\n\t\tthis._upState = new Vector3();\n\t\tthis._zoomState = 1;\n\t\tthis._nearPos = 0;\n\t\tthis._farPos = 0;\n\n\t\tthis._gizmoMatrixState = new Matrix4();\n\n\t\t//initial values\n\t\tthis._up0 = new Vector3();\n\t\tthis._zoom0 = 1;\n\t\tthis._fov0 = 0;\n\t\tthis._initialNear = 0;\n\t\tthis._nearPos0 = 0;\n\t\tthis._initialFar = 0;\n\t\tthis._farPos0 = 0;\n\t\tthis._cameraMatrixState0 = new Matrix4();\n\t\tthis._gizmoMatrixState0 = new Matrix4();\n\n\t\t//pointers array\n\t\tthis._button = - 1;\n\t\tthis._touchStart = [];\n\t\tthis._touchCurrent = [];\n\t\tthis._input = INPUT.NONE;\n\n\t\t//two fingers touch interaction\n\t\tthis._switchSensibility = 32;\t//minimum movement to be performed to fire single pan start after the second finger has been released\n\t\tthis._startFingerDistance = 0; //distance between two fingers\n\t\tthis._currentFingerDistance = 0;\n\t\tthis._startFingerRotation = 0; //amount of rotation performed with two fingers\n\t\tthis._currentFingerRotation = 0;\n\n\t\t//double tap\n\t\tthis._devPxRatio = 0;\n\t\tthis._downValid = true;\n\t\tthis._nclicks = 0;\n\t\tthis._downEvents = [];\n\t\tthis._downStart = 0;\t//pointerDown time\n\t\tthis._clickStart = 0;\t//first click time\n\t\tthis._maxDownTime = 250;\n\t\tthis._maxInterval = 300;\n\t\tthis._posThreshold = 24;\n\t\tthis._movementThreshold = 24;\n\n\t\t//cursor positions\n\t\tthis._currentCursorPosition = new Vector3();\n\t\tthis._startCursorPosition = new Vector3();\n\n\t\t//grid\n\t\tthis._grid = null; //grid to be visualized during pan operation\n\t\tthis._gridPosition = new Vector3();\n\n\t\t//gizmos\n\t\tthis._gizmos = new Group();\n\t\tthis._curvePts = 128;\n\n\n\t\t//animations\n\t\tthis._timeStart = - 1; //initial time\n\t\tthis._animationId = - 1;\n\n\t\t//focus animation\n\t\tthis.focusAnimationTime = 500; //duration of focus animation in ms\n\n\t\t//rotate animation\n\t\tthis._timePrev = 0; //time at which previous rotate operation has been detected\n\t\tthis._timeCurrent = 0; //time at which current rotate operation has been detected\n\t\tthis._anglePrev = 0; //angle of previous rotation\n\t\tthis._angleCurrent = 0; //angle of current rotation\n\t\tthis._cursorPosPrev = new Vector3();\t//cursor position when previous rotate operation has been detected\n\t\tthis._cursorPosCurr = new Vector3();//cursor position when current rotate operation has been detected\n\t\tthis._wPrev = 0; //angular velocity of the previous rotate operation\n\t\tthis._wCurr = 0; //angular velocity of the current rotate operation\n\n\n\t\t//parameters\n\t\tthis.adjustNearFar = false;\n\t\tthis.scaleFactor = 1.1;\t//zoom/distance multiplier\n\t\tthis.dampingFactor = 25;\n\t\tthis.wMax = 20;\t//maximum angular velocity allowed\n\t\tthis.enableAnimations = true; //if animations should be performed\n\t\tthis.enableGrid = false; //if grid should be showed during pan operation\n\t\tthis.cursorZoom = false;\t//if wheel zoom should be cursor centered\n\t\tthis.minFov = 5;\n\t\tthis.maxFov = 90;\n\n\t\tthis.enabled = true;\n\t\tthis.enablePan = true;\n\t\tthis.enableRotate = true;\n\t\tthis.enableZoom = true;\n\t\tthis.enableGizmos = true;\n\n\t\tthis.minDistance = 0;\n\t\tthis.maxDistance = Infinity;\n\t\tthis.minZoom = 0;\n\t\tthis.maxZoom = Infinity;\n\n\t\t//trackball parameters\n\t\tthis._tbRadius = 1;\n\n\t\t//FSA\n\t\tthis._state = STATE.IDLE;\n\n\t\tthis.setCamera( camera );\n\n\t\tif ( this.scene != null ) {\n\n\t\t\tthis.scene.add( this._gizmos );\n\n\t\t}\n\n\t\tthis.domElement.style.touchAction = 'none';\n\t\tthis._devPxRatio = window.devicePixelRatio;\n\n\t\tthis.initializeMouseActions();\n\n\t\tthis._onContextMenu = onContextMenu.bind( this );\n\t\tthis._onWheel = onWheel.bind( this );\n\t\tthis._onPointerUp = onPointerUp.bind( this );\n\t\tthis._onPointerMove = onPointerMove.bind( this );\n\t\tthis._onPointerDown = onPointerDown.bind( this );\n\t\tthis._onPointerCancel = onPointerCancel.bind( this );\n\t\tthis._onWindowResize = onWindowResize.bind( this );\n\n\t\tthis.domElement.addEventListener( 'contextmenu', this._onContextMenu );\n\t\tthis.domElement.addEventListener( 'wheel', this._onWheel );\n\t\tthis.domElement.addEventListener( 'pointerdown', this._onPointerDown );\n\t\tthis.domElement.addEventListener( 'pointercancel', this._onPointerCancel );\n\n\t\twindow.addEventListener( 'resize', this._onWindowResize );\n\n\t}\n\n\tonSinglePanStart( event, operation ) {\n\n\t\tif ( this.enabled ) {\n\n\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\tthis.setCenter( event.clientX, event.clientY );\n\n\t\t\tswitch ( operation ) {\n\n\t\t\t\tcase 'PAN':\n\n\t\t\t\t\tif ( ! this.enablePan ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( this._animationId != - 1 ) {\n\n\t\t\t\t\t\tcancelAnimationFrame( this._animationId );\n\t\t\t\t\t\tthis._animationId = - 1;\n\t\t\t\t\t\tthis._timeStart = - 1;\n\n\t\t\t\t\t\tthis.activateGizmos( false );\n\t\t\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.updateTbState( STATE.PAN, true );\n\t\t\t\t\tthis._startCursorPosition.copy( this.unprojectOnTbPlane( this.camera, _center.x, _center.y, this.domElement ) );\n\t\t\t\t\tif ( this.enableGrid ) {\n\n\t\t\t\t\t\tthis.drawGrid();\n\t\t\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ROTATE':\n\n\t\t\t\t\tif ( ! this.enableRotate ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( this._animationId != - 1 ) {\n\n\t\t\t\t\t\tcancelAnimationFrame( this._animationId );\n\t\t\t\t\t\tthis._animationId = - 1;\n\t\t\t\t\t\tthis._timeStart = - 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.updateTbState( STATE.ROTATE, true );\n\t\t\t\t\tthis._startCursorPosition.copy( this.unprojectOnTbSurface( this.camera, _center.x, _center.y, this.domElement, this._tbRadius ) );\n\t\t\t\t\tthis.activateGizmos( true );\n\t\t\t\t\tif ( this.enableAnimations ) {\n\n\t\t\t\t\t\tthis._timePrev = this._timeCurrent = performance.now();\n\t\t\t\t\t\tthis._angleCurrent = this._anglePrev = 0;\n\t\t\t\t\t\tthis._cursorPosPrev.copy( this._startCursorPosition );\n\t\t\t\t\t\tthis._cursorPosCurr.copy( this._cursorPosPrev );\n\t\t\t\t\t\tthis._wCurr = 0;\n\t\t\t\t\t\tthis._wPrev = this._wCurr;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.dispatchEvent( _changeEvent );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'FOV':\n\n\t\t\t\t\tif ( ! this.camera.isPerspectiveCamera || ! this.enableZoom ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( this._animationId != - 1 ) {\n\n\t\t\t\t\t\tcancelAnimationFrame( this._animationId );\n\t\t\t\t\t\tthis._animationId = - 1;\n\t\t\t\t\t\tthis._timeStart = - 1;\n\n\t\t\t\t\t\tthis.activateGizmos( false );\n\t\t\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.updateTbState( STATE.FOV, true );\n\t\t\t\t\tthis._startCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );\n\t\t\t\t\tthis._currentCursorPosition.copy( this._startCursorPosition );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ZOOM':\n\n\t\t\t\t\tif ( ! this.enableZoom ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( this._animationId != - 1 ) {\n\n\t\t\t\t\t\tcancelAnimationFrame( this._animationId );\n\t\t\t\t\t\tthis._animationId = - 1;\n\t\t\t\t\t\tthis._timeStart = - 1;\n\n\t\t\t\t\t\tthis.activateGizmos( false );\n\t\t\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.updateTbState( STATE.SCALE, true );\n\t\t\t\t\tthis._startCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );\n\t\t\t\t\tthis._currentCursorPosition.copy( this._startCursorPosition );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tonSinglePanMove( event, opState ) {\n\n\t\tif ( this.enabled ) {\n\n\t\t\tconst restart = opState != this._state;\n\t\t\tthis.setCenter( event.clientX, event.clientY );\n\n\t\t\tswitch ( opState ) {\n\n\t\t\t\tcase STATE.PAN:\n\n\t\t\t\t\tif ( this.enablePan ) {\n\n\t\t\t\t\t\tif ( restart ) {\n\n\t\t\t\t\t\t\t//switch to pan operation\n\n\t\t\t\t\t\t\tthis.dispatchEvent( _endEvent );\n\t\t\t\t\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\t\t\t\t\tthis.updateTbState( opState, true );\n\t\t\t\t\t\t\tthis._startCursorPosition.copy( this.unprojectOnTbPlane( this.camera, _center.x, _center.y, this.domElement ) );\n\t\t\t\t\t\t\tif ( this.enableGrid ) {\n\n\t\t\t\t\t\t\t\tthis.drawGrid();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.activateGizmos( false );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t//continue with pan operation\n\t\t\t\t\t\t\tthis._currentCursorPosition.copy( this.unprojectOnTbPlane( this.camera, _center.x, _center.y, this.domElement ) );\n\t\t\t\t\t\t\tthis.applyTransformMatrix( this.pan( this._startCursorPosition, this._currentCursorPosition ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.ROTATE:\n\n\t\t\t\t\tif ( this.enableRotate ) {\n\n\t\t\t\t\t\tif ( restart ) {\n\n\t\t\t\t\t\t\t//switch to rotate operation\n\n\t\t\t\t\t\t\tthis.dispatchEvent( _endEvent );\n\t\t\t\t\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\t\t\t\t\tthis.updateTbState( opState, true );\n\t\t\t\t\t\t\tthis._startCursorPosition.copy( this.unprojectOnTbSurface( this.camera, _center.x, _center.y, this.domElement, this._tbRadius ) );\n\n\t\t\t\t\t\t\tif ( this.enableGrid ) {\n\n\t\t\t\t\t\t\t\tthis.disposeGrid();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.activateGizmos( true );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t//continue with rotate operation\n\t\t\t\t\t\t\tthis._currentCursorPosition.copy( this.unprojectOnTbSurface( this.camera, _center.x, _center.y, this.domElement, this._tbRadius ) );\n\n\t\t\t\t\t\t\tconst distance = this._startCursorPosition.distanceTo( this._currentCursorPosition );\n\t\t\t\t\t\t\tconst angle = this._startCursorPosition.angleTo( this._currentCursorPosition );\n\t\t\t\t\t\t\tconst amount = Math.max( distance / this._tbRadius, angle ); //effective rotation angle\n\n\t\t\t\t\t\t\tthis.applyTransformMatrix( this.rotate( this.calculateRotationAxis( this._startCursorPosition, this._currentCursorPosition ), amount ) );\n\n\t\t\t\t\t\t\tif ( this.enableAnimations ) {\n\n\t\t\t\t\t\t\t\tthis._timePrev = this._timeCurrent;\n\t\t\t\t\t\t\t\tthis._timeCurrent = performance.now();\n\t\t\t\t\t\t\t\tthis._anglePrev = this._angleCurrent;\n\t\t\t\t\t\t\t\tthis._angleCurrent = amount;\n\t\t\t\t\t\t\t\tthis._cursorPosPrev.copy( this._cursorPosCurr );\n\t\t\t\t\t\t\t\tthis._cursorPosCurr.copy( this._currentCursorPosition );\n\t\t\t\t\t\t\t\tthis._wPrev = this._wCurr;\n\t\t\t\t\t\t\t\tthis._wCurr = this.calculateAngularSpeed( this._anglePrev, this._angleCurrent, this._timePrev, this._timeCurrent );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.SCALE:\n\n\t\t\t\t\tif ( this.enableZoom ) {\n\n\t\t\t\t\t\tif ( restart ) {\n\n\t\t\t\t\t\t\t//switch to zoom operation\n\n\t\t\t\t\t\t\tthis.dispatchEvent( _endEvent );\n\t\t\t\t\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\t\t\t\t\tthis.updateTbState( opState, true );\n\t\t\t\t\t\t\tthis._startCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );\n\t\t\t\t\t\t\tthis._currentCursorPosition.copy( this._startCursorPosition );\n\n\t\t\t\t\t\t\tif ( this.enableGrid ) {\n\n\t\t\t\t\t\t\t\tthis.disposeGrid();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.activateGizmos( false );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t//continue with zoom operation\n\t\t\t\t\t\t\tconst screenNotches = 8;\t//how many wheel notches corresponds to a full screen pan\n\t\t\t\t\t\t\tthis._currentCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );\n\n\t\t\t\t\t\t\tconst movement = this._currentCursorPosition.y - this._startCursorPosition.y;\n\n\t\t\t\t\t\t\tlet size = 1;\n\n\t\t\t\t\t\t\tif ( movement < 0 ) {\n\n\t\t\t\t\t\t\t\tsize = 1 / ( Math.pow( this.scaleFactor, - movement * screenNotches ) );\n\n\t\t\t\t\t\t\t} else if ( movement > 0 ) {\n\n\t\t\t\t\t\t\t\tsize = Math.pow( this.scaleFactor, movement * screenNotches );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis._v3_1.setFromMatrixPosition( this._gizmoMatrixState );\n\n\t\t\t\t\t\t\tthis.applyTransformMatrix( this.scale( size, this._v3_1 ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.FOV:\n\n\t\t\t\t\tif ( this.enableZoom && this.camera.isPerspectiveCamera ) {\n\n\t\t\t\t\t\tif ( restart ) {\n\n\t\t\t\t\t\t\t//switch to fov operation\n\n\t\t\t\t\t\t\tthis.dispatchEvent( _endEvent );\n\t\t\t\t\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\t\t\t\t\tthis.updateTbState( opState, true );\n\t\t\t\t\t\t\tthis._startCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );\n\t\t\t\t\t\t\tthis._currentCursorPosition.copy( this._startCursorPosition );\n\n\t\t\t\t\t\t\tif ( this.enableGrid ) {\n\n\t\t\t\t\t\t\t\tthis.disposeGrid();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.activateGizmos( false );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t//continue with fov operation\n\t\t\t\t\t\t\tconst screenNotches = 8;\t//how many wheel notches corresponds to a full screen pan\n\t\t\t\t\t\t\tthis._currentCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );\n\n\t\t\t\t\t\t\tconst movement = this._currentCursorPosition.y - this._startCursorPosition.y;\n\n\t\t\t\t\t\t\tlet size = 1;\n\n\t\t\t\t\t\t\tif ( movement < 0 ) {\n\n\t\t\t\t\t\t\t\tsize = 1 / ( Math.pow( this.scaleFactor, - movement * screenNotches ) );\n\n\t\t\t\t\t\t\t} else if ( movement > 0 ) {\n\n\t\t\t\t\t\t\t\tsize = Math.pow( this.scaleFactor, movement * screenNotches );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis._v3_1.setFromMatrixPosition( this._cameraMatrixState );\n\t\t\t\t\t\t\tconst x = this._v3_1.distanceTo( this._gizmos.position );\n\t\t\t\t\t\t\tlet xNew = x / size; //distance between camera and gizmos if scale(size, scalepoint) would be performed\n\n\t\t\t\t\t\t\t//check min and max distance\n\t\t\t\t\t\t\txNew = MathUtils.clamp( xNew, this.minDistance, this.maxDistance );\n\n\t\t\t\t\t\t\tconst y = x * Math.tan( MathUtils.DEG2RAD * this._fovState * 0.5 );\n\n\t\t\t\t\t\t\t//calculate new fov\n\t\t\t\t\t\t\tlet newFov = MathUtils.RAD2DEG * ( Math.atan( y / xNew ) * 2 );\n\n\t\t\t\t\t\t\t//check min and max fov\n\t\t\t\t\t\t\tnewFov = MathUtils.clamp( newFov, this.minFov, this.maxFov );\n\n\t\t\t\t\t\t\tconst newDistance = y / Math.tan( MathUtils.DEG2RAD * ( newFov / 2 ) );\n\t\t\t\t\t\t\tsize = x / newDistance;\n\t\t\t\t\t\t\tthis._v3_2.setFromMatrixPosition( this._gizmoMatrixState );\n\n\t\t\t\t\t\t\tthis.setFov( newFov );\n\t\t\t\t\t\t\tthis.applyTransformMatrix( this.scale( size, this._v3_2, false ) );\n\n\t\t\t\t\t\t\t//adjusting distance\n\t\t\t\t\t\t\t_offset.copy( this._gizmos.position ).sub( this.camera.position ).normalize().multiplyScalar( newDistance / x );\n\t\t\t\t\t\t\tthis._m4_1.makeTranslation( _offset.x, _offset.y, _offset.z );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t}\n\n\t}\n\n\tonSinglePanEnd() {\n\n\t\tif ( this._state == STATE.ROTATE ) {\n\n\n\t\t\tif ( ! this.enableRotate ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( this.enableAnimations ) {\n\n\t\t\t\t//perform rotation animation\n\t\t\t\tconst deltaTime = ( performance.now() - this._timeCurrent );\n\t\t\t\tif ( deltaTime < 120 ) {\n\n\t\t\t\t\tconst w = Math.abs( ( this._wPrev + this._wCurr ) / 2 );\n\n\t\t\t\t\tconst self = this;\n\t\t\t\t\tthis._animationId = window.requestAnimationFrame( function ( t ) {\n\n\t\t\t\t\t\tself.updateTbState( STATE.ANIMATION_ROTATE, true );\n\t\t\t\t\t\tconst rotationAxis = self.calculateRotationAxis( self._cursorPosPrev, self._cursorPosCurr );\n\n\t\t\t\t\t\tself.onRotationAnim( t, rotationAxis, Math.min( w, self.wMax ) );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t//cursor has been standing still for over 120 ms since last movement\n\t\t\t\t\tthis.updateTbState( STATE.IDLE, false );\n\t\t\t\t\tthis.activateGizmos( false );\n\t\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis.updateTbState( STATE.IDLE, false );\n\t\t\t\tthis.activateGizmos( false );\n\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t}\n\n\t\t} else if ( this._state == STATE.PAN || this._state == STATE.IDLE ) {\n\n\t\t\tthis.updateTbState( STATE.IDLE, false );\n\n\t\t\tif ( this.enableGrid ) {\n\n\t\t\t\tthis.disposeGrid();\n\n\t\t\t}\n\n\t\t\tthis.activateGizmos( false );\n\t\t\tthis.dispatchEvent( _changeEvent );\n\n\n\t\t}\n\n\t\tthis.dispatchEvent( _endEvent );\n\n\t}\n\n\tonDoubleTap( event ) {\n\n\t\tif ( this.enabled && this.enablePan && this.scene != null ) {\n\n\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\tthis.setCenter( event.clientX, event.clientY );\n\t\t\tconst hitP = this.unprojectOnObj( this.getCursorNDC( _center.x, _center.y, this.domElement ), this.camera );\n\n\t\t\tif ( hitP != null && this.enableAnimations ) {\n\n\t\t\t\tconst self = this;\n\t\t\t\tif ( this._animationId != - 1 ) {\n\n\t\t\t\t\twindow.cancelAnimationFrame( this._animationId );\n\n\t\t\t\t}\n\n\t\t\t\tthis._timeStart = - 1;\n\t\t\t\tthis._animationId = window.requestAnimationFrame( function ( t ) {\n\n\t\t\t\t\tself.updateTbState( STATE.ANIMATION_FOCUS, true );\n\t\t\t\t\tself.onFocusAnim( t, hitP, self._cameraMatrixState, self._gizmoMatrixState );\n\n\t\t\t\t} );\n\n\t\t\t} else if ( hitP != null && ! this.enableAnimations ) {\n\n\t\t\t\tthis.updateTbState( STATE.FOCUS, true );\n\t\t\t\tthis.focus( hitP, this.scaleFactor );\n\t\t\t\tthis.updateTbState( STATE.IDLE, false );\n\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.dispatchEvent( _endEvent );\n\n\t}\n\n\tonDoublePanStart() {\n\n\t\tif ( this.enabled && this.enablePan ) {\n\n\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\tthis.updateTbState( STATE.PAN, true );\n\n\t\t\tthis.setCenter( ( this._touchCurrent[ 0 ].clientX + this._touchCurrent[ 1 ].clientX ) / 2, ( this._touchCurrent[ 0 ].clientY + this._touchCurrent[ 1 ].clientY ) / 2 );\n\t\t\tthis._startCursorPosition.copy( this.unprojectOnTbPlane( this.camera, _center.x, _center.y, this.domElement, true ) );\n\t\t\tthis._currentCursorPosition.copy( this._startCursorPosition );\n\n\t\t\tthis.activateGizmos( false );\n\n\t\t}\n\n\t}\n\n\tonDoublePanMove() {\n\n\t\tif ( this.enabled && this.enablePan ) {\n\n\t\t\tthis.setCenter( ( this._touchCurrent[ 0 ].clientX + this._touchCurrent[ 1 ].clientX ) / 2, ( this._touchCurrent[ 0 ].clientY + this._touchCurrent[ 1 ].clientY ) / 2 );\n\n\t\t\tif ( this._state != STATE.PAN ) {\n\n\t\t\t\tthis.updateTbState( STATE.PAN, true );\n\t\t\t\tthis._startCursorPosition.copy( this._currentCursorPosition );\n\n\t\t\t}\n\n\t\t\tthis._currentCursorPosition.copy( this.unprojectOnTbPlane( this.camera, _center.x, _center.y, this.domElement, true ) );\n\t\t\tthis.applyTransformMatrix( this.pan( this._startCursorPosition, this._currentCursorPosition, true ) );\n\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t}\n\n\t}\n\n\tonDoublePanEnd() {\n\n\t\tthis.updateTbState( STATE.IDLE, false );\n\t\tthis.dispatchEvent( _endEvent );\n\n\t}\n\n\tonRotateStart() {\n\n\t\tif ( this.enabled && this.enableRotate ) {\n\n\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\tthis.updateTbState( STATE.ZROTATE, true );\n\n\t\t\t//this._startFingerRotation = event.rotation;\n\n\t\t\tthis._startFingerRotation = this.getAngle( this._touchCurrent[ 1 ], this._touchCurrent[ 0 ] ) + this.getAngle( this._touchStart[ 1 ], this._touchStart[ 0 ] );\n\t\t\tthis._currentFingerRotation = this._startFingerRotation;\n\n\t\t\tthis.camera.getWorldDirection( this._rotationAxis ); //rotation axis\n\n\t\t\tif ( ! this.enablePan && ! this.enableZoom ) {\n\n\t\t\t\tthis.activateGizmos( true );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tonRotateMove() {\n\n\t\tif ( this.enabled && this.enableRotate ) {\n\n\t\t\tthis.setCenter( ( this._touchCurrent[ 0 ].clientX + this._touchCurrent[ 1 ].clientX ) / 2, ( this._touchCurrent[ 0 ].clientY + this._touchCurrent[ 1 ].clientY ) / 2 );\n\t\t\tlet rotationPoint;\n\n\t\t\tif ( this._state != STATE.ZROTATE ) {\n\n\t\t\t\tthis.updateTbState( STATE.ZROTATE, true );\n\t\t\t\tthis._startFingerRotation = this._currentFingerRotation;\n\n\t\t\t}\n\n\t\t\t//this._currentFingerRotation = event.rotation;\n\t\t\tthis._currentFingerRotation = this.getAngle( this._touchCurrent[ 1 ], this._touchCurrent[ 0 ] ) + this.getAngle( this._touchStart[ 1 ], this._touchStart[ 0 ] );\n\n\t\t\tif ( ! this.enablePan ) {\n\n\t\t\t\trotationPoint = new Vector3().setFromMatrixPosition( this._gizmoMatrixState );\n\n\t\t\t} else {\n\n\t\t\t\tthis._v3_2.setFromMatrixPosition( this._gizmoMatrixState );\n\t\t\t\trotationPoint = this.unprojectOnTbPlane( this.camera, _center.x, _center.y, this.domElement ).applyQuaternion( this.camera.quaternion ).multiplyScalar( 1 / this.camera.zoom ).add( this._v3_2 );\n\n\t\t\t}\n\n\t\t\tconst amount = MathUtils.DEG2RAD * ( this._startFingerRotation - this._currentFingerRotation );\n\n\t\t\tthis.applyTransformMatrix( this.zRotate( rotationPoint, amount ) );\n\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t}\n\n\t}\n\n\tonRotateEnd() {\n\n\t\tthis.updateTbState( STATE.IDLE, false );\n\t\tthis.activateGizmos( false );\n\t\tthis.dispatchEvent( _endEvent );\n\n\t}\n\n\tonPinchStart() {\n\n\t\tif ( this.enabled && this.enableZoom ) {\n\n\t\t\tthis.dispatchEvent( _startEvent );\n\t\t\tthis.updateTbState( STATE.SCALE, true );\n\n\t\t\tthis._startFingerDistance = this.calculatePointersDistance( this._touchCurrent[ 0 ], this._touchCurrent[ 1 ] );\n\t\t\tthis._currentFingerDistance = this._startFingerDistance;\n\n\t\t\tthis.activateGizmos( false );\n\n\t\t}\n\n\t}\n\n\tonPinchMove() {\n\n\t\tif ( this.enabled && this.enableZoom ) {\n\n\t\t\tthis.setCenter( ( this._touchCurrent[ 0 ].clientX + this._touchCurrent[ 1 ].clientX ) / 2, ( this._touchCurrent[ 0 ].clientY + this._touchCurrent[ 1 ].clientY ) / 2 );\n\t\t\tconst minDistance = 12; //minimum distance between fingers (in css pixels)\n\n\t\t\tif ( this._state != STATE.SCALE ) {\n\n\t\t\t\tthis._startFingerDistance = this._currentFingerDistance;\n\t\t\t\tthis.updateTbState( STATE.SCALE, true );\n\n\t\t\t}\n\n\t\t\tthis._currentFingerDistance = Math.max( this.calculatePointersDistance( this._touchCurrent[ 0 ], this._touchCurrent[ 1 ] ), minDistance * this._devPxRatio );\n\t\t\tconst amount = this._currentFingerDistance / this._startFingerDistance;\n\n\t\t\tlet scalePoint;\n\n\t\t\tif ( ! this.enablePan ) {\n\n\t\t\t\tscalePoint = this._gizmos.position;\n\n\t\t\t} else {\n\n\t\t\t\tif ( this.camera.isOrthographicCamera ) {\n\n\t\t\t\t\tscalePoint = this.unprojectOnTbPlane( this.camera, _center.x, _center.y, this.domElement )\n\t\t\t\t\t\t.applyQuaternion( this.camera.quaternion )\n\t\t\t\t\t\t.multiplyScalar( 1 / this.camera.zoom )\n\t\t\t\t\t\t.add( this._gizmos.position );\n\n\t\t\t\t} else if ( this.camera.isPerspectiveCamera ) {\n\n\t\t\t\t\tscalePoint = this.unprojectOnTbPlane( this.camera, _center.x, _center.y, this.domElement )\n\t\t\t\t\t\t.applyQuaternion( this.camera.quaternion )\n\t\t\t\t\t\t.add( this._gizmos.position );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.applyTransformMatrix( this.scale( amount, scalePoint ) );\n\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t}\n\n\t}\n\n\tonPinchEnd() {\n\n\t\tthis.updateTbState( STATE.IDLE, false );\n\t\tthis.dispatchEvent( _endEvent );\n\n\t}\n\n\tonTriplePanStart() {\n\n\t\tif ( this.enabled && this.enableZoom ) {\n\n\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\tthis.updateTbState( STATE.SCALE, true );\n\n\t\t\t//const center = event.center;\n\t\t\tlet clientX = 0;\n\t\t\tlet clientY = 0;\n\t\t\tconst nFingers = this._touchCurrent.length;\n\n\t\t\tfor ( let i = 0; i < nFingers; i ++ ) {\n\n\t\t\t\tclientX += this._touchCurrent[ i ].clientX;\n\t\t\t\tclientY += this._touchCurrent[ i ].clientY;\n\n\t\t\t}\n\n\t\t\tthis.setCenter( clientX / nFingers, clientY / nFingers );\n\n\t\t\tthis._startCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );\n\t\t\tthis._currentCursorPosition.copy( this._startCursorPosition );\n\n\t\t}\n\n\t}\n\n\tonTriplePanMove() {\n\n\t\tif ( this.enabled && this.enableZoom ) {\n\n\t\t\t//\t  fov / 2\n\t\t\t//\t\t|\\\n\t\t\t//\t\t| \\\n\t\t\t//\t\t|  \\\n\t\t\t//\tx\t|\t\\\n\t\t\t//\t\t| \t \\\n\t\t\t//\t\t| \t  \\\n\t\t\t//\t\t| _ _ _\\\n\t\t\t//\t\t\ty\n\n\t\t\t//const center = event.center;\n\t\t\tlet clientX = 0;\n\t\t\tlet clientY = 0;\n\t\t\tconst nFingers = this._touchCurrent.length;\n\n\t\t\tfor ( let i = 0; i < nFingers; i ++ ) {\n\n\t\t\t\tclientX += this._touchCurrent[ i ].clientX;\n\t\t\t\tclientY += this._touchCurrent[ i ].clientY;\n\n\t\t\t}\n\n\t\t\tthis.setCenter( clientX / nFingers, clientY / nFingers );\n\n\t\t\tconst screenNotches = 8;\t//how many wheel notches corresponds to a full screen pan\n\t\t\tthis._currentCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );\n\n\t\t\tconst movement = this._currentCursorPosition.y - this._startCursorPosition.y;\n\n\t\t\tlet size = 1;\n\n\t\t\tif ( movement < 0 ) {\n\n\t\t\t\tsize = 1 / ( Math.pow( this.scaleFactor, - movement * screenNotches ) );\n\n\t\t\t} else if ( movement > 0 ) {\n\n\t\t\t\tsize = Math.pow( this.scaleFactor, movement * screenNotches );\n\n\t\t\t}\n\n\t\t\tthis._v3_1.setFromMatrixPosition( this._cameraMatrixState );\n\t\t\tconst x = this._v3_1.distanceTo( this._gizmos.position );\n\t\t\tlet xNew = x / size; //distance between camera and gizmos if scale(size, scalepoint) would be performed\n\n\t\t\t//check min and max distance\n\t\t\txNew = MathUtils.clamp( xNew, this.minDistance, this.maxDistance );\n\n\t\t\tconst y = x * Math.tan( MathUtils.DEG2RAD * this._fovState * 0.5 );\n\n\t\t\t//calculate new fov\n\t\t\tlet newFov = MathUtils.RAD2DEG * ( Math.atan( y / xNew ) * 2 );\n\n\t\t\t//check min and max fov\n\t\t\tnewFov = MathUtils.clamp( newFov, this.minFov, this.maxFov );\n\n\t\t\tconst newDistance = y / Math.tan( MathUtils.DEG2RAD * ( newFov / 2 ) );\n\t\t\tsize = x / newDistance;\n\t\t\tthis._v3_2.setFromMatrixPosition( this._gizmoMatrixState );\n\n\t\t\tthis.setFov( newFov );\n\t\t\tthis.applyTransformMatrix( this.scale( size, this._v3_2, false ) );\n\n\t\t\t//adjusting distance\n\t\t\t_offset.copy( this._gizmos.position ).sub( this.camera.position ).normalize().multiplyScalar( newDistance / x );\n\t\t\tthis._m4_1.makeTranslation( _offset.x, _offset.y, _offset.z );\n\n\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t}\n\n\t}\n\n\tonTriplePanEnd() {\n\n\t\tthis.updateTbState( STATE.IDLE, false );\n\t\tthis.dispatchEvent( _endEvent );\n\t\t//this.dispatchEvent( _changeEvent );\n\n\t}\n\n\t/**\n\t * Set _center's x/y coordinates\n\t * @param {Number} clientX\n\t * @param {Number} clientY\n\t */\n\tsetCenter( clientX, clientY ) {\n\n\t\t_center.x = clientX;\n\t\t_center.y = clientY;\n\n\t}\n\n\t/**\n\t * Set default mouse actions\n\t */\n\tinitializeMouseActions() {\n\n\t\tthis.setMouseAction( 'PAN', 0, 'CTRL' );\n\t\tthis.setMouseAction( 'PAN', 2 );\n\n\t\tthis.setMouseAction( 'ROTATE', 0 );\n\n\t\tthis.setMouseAction( 'ZOOM', 'WHEEL' );\n\t\tthis.setMouseAction( 'ZOOM', 1 );\n\n\t\tthis.setMouseAction( 'FOV', 'WHEEL', 'SHIFT' );\n\t\tthis.setMouseAction( 'FOV', 1, 'SHIFT' );\n\n\n\t}\n\n\t/**\n\t * Compare two mouse actions\n\t * @param {Object} action1\n\t * @param {Object} action2\n\t * @returns {Boolean} True if action1 and action 2 are the same mouse action, false otherwise\n\t */\n\tcompareMouseAction( action1, action2 ) {\n\n\t\tif ( action1.operation == action2.operation ) {\n\n\t\t\tif ( action1.mouse == action2.mouse && action1.key == action2.key ) {\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Set a new mouse action by specifying the operation to be performed and a mouse/key combination. In case of conflict, replaces the existing one\n\t * @param {String} operation The operation to be performed ('PAN', 'ROTATE', 'ZOOM', 'FOV)\n\t * @param {*} mouse A mouse button (0, 1, 2) or 'WHEEL' for wheel notches\n\t * @param {*} key The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed\n\t * @returns {Boolean} True if the mouse action has been successfully added, false otherwise\n\t */\n\tsetMouseAction( operation, mouse, key = null ) {\n\n\t\tconst operationInput = [ 'PAN', 'ROTATE', 'ZOOM', 'FOV' ];\n\t\tconst mouseInput = [ 0, 1, 2, 'WHEEL' ];\n\t\tconst keyInput = [ 'CTRL', 'SHIFT', null ];\n\t\tlet state;\n\n\t\tif ( ! operationInput.includes( operation ) || ! mouseInput.includes( mouse ) || ! keyInput.includes( key ) ) {\n\n\t\t\t//invalid parameters\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( mouse == 'WHEEL' ) {\n\n\t\t\tif ( operation != 'ZOOM' && operation != 'FOV' ) {\n\n\t\t\t\t//cannot associate 2D operation to 1D input\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\tswitch ( operation ) {\n\n\t\t\tcase 'PAN':\n\n\t\t\t\tstate = STATE.PAN;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ROTATE':\n\n\t\t\t\tstate = STATE.ROTATE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZOOM':\n\n\t\t\t\tstate = STATE.SCALE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'FOV':\n\n\t\t\t\tstate = STATE.FOV;\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tconst action = {\n\n\t\t\toperation: operation,\n\t\t\tmouse: mouse,\n\t\t\tkey: key,\n\t\t\tstate: state\n\n\t\t};\n\n\t\tfor ( let i = 0; i < this.mouseActions.length; i ++ ) {\n\n\t\t\tif ( this.mouseActions[ i ].mouse == action.mouse && this.mouseActions[ i ].key == action.key ) {\n\n\t\t\t\tthis.mouseActions.splice( i, 1, action );\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.mouseActions.push( action );\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Remove a mouse action by specifying its mouse/key combination\n\t * @param {*} mouse A mouse button (0, 1, 2) or 'WHEEL' for wheel notches\n\t * @param {*} key The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed\n\t * @returns {Boolean} True if the operation has been succesfully removed, false otherwise\n\t */\n\tunsetMouseAction( mouse, key = null ) {\n\n\t\tfor ( let i = 0; i < this.mouseActions.length; i ++ ) {\n\n\t\t\tif ( this.mouseActions[ i ].mouse == mouse && this.mouseActions[ i ].key == key ) {\n\n\t\t\t\tthis.mouseActions.splice( i, 1 );\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Return the operation associated to a mouse/keyboard combination\n\t * @param {*} mouse A mouse button (0, 1, 2) or 'WHEEL' for wheel notches\n\t * @param {*} key The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed\n\t * @returns The operation if it has been found, null otherwise\n\t */\n\tgetOpFromAction( mouse, key ) {\n\n\t\tlet action;\n\n\t\tfor ( let i = 0; i < this.mouseActions.length; i ++ ) {\n\n\t\t\taction = this.mouseActions[ i ];\n\t\t\tif ( action.mouse == mouse && action.key == key ) {\n\n\t\t\t\treturn action.operation;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( key != null ) {\n\n\t\t\tfor ( let i = 0; i < this.mouseActions.length; i ++ ) {\n\n\t\t\t\taction = this.mouseActions[ i ];\n\t\t\t\tif ( action.mouse == mouse && action.key == null ) {\n\n\t\t\t\t\treturn action.operation;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t/**\n\t * Get the operation associated to mouse and key combination and returns the corresponding FSA state\n\t * @param {Number} mouse Mouse button\n\t * @param {String} key Keyboard modifier\n\t * @returns The FSA state obtained from the operation associated to mouse/keyboard combination\n\t */\n\tgetOpStateFromAction( mouse, key ) {\n\n\t\tlet action;\n\n\t\tfor ( let i = 0; i < this.mouseActions.length; i ++ ) {\n\n\t\t\taction = this.mouseActions[ i ];\n\t\t\tif ( action.mouse == mouse && action.key == key ) {\n\n\t\t\t\treturn action.state;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( key != null ) {\n\n\t\t\tfor ( let i = 0; i < this.mouseActions.length; i ++ ) {\n\n\t\t\t\taction = this.mouseActions[ i ];\n\t\t\t\tif ( action.mouse == mouse && action.key == null ) {\n\n\t\t\t\t\treturn action.state;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t/**\n\t * Calculate the angle between two pointers\n\t * @param {PointerEvent} p1\n\t * @param {PointerEvent} p2\n\t * @returns {Number} The angle between two pointers in degrees\n\t */\n\tgetAngle( p1, p2 ) {\n\n\t\treturn Math.atan2( p2.clientY - p1.clientY, p2.clientX - p1.clientX ) * 180 / Math.PI;\n\n\t}\n\n\t/**\n\t * Update a PointerEvent inside current pointerevents array\n\t * @param {PointerEvent} event\n\t */\n\tupdateTouchEvent( event ) {\n\n\t\tfor ( let i = 0; i < this._touchCurrent.length; i ++ ) {\n\n\t\t\tif ( this._touchCurrent[ i ].pointerId == event.pointerId ) {\n\n\t\t\t\tthis._touchCurrent.splice( i, 1, event );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Apply a transformation matrix, to the camera and gizmos\n\t * @param {Object} transformation Object containing matrices to apply to camera and gizmos\n\t */\n\tapplyTransformMatrix( transformation ) {\n\n\t\tif ( transformation.camera != null ) {\n\n\t\t\tthis._m4_1.copy( this._cameraMatrixState ).premultiply( transformation.camera );\n\t\t\tthis._m4_1.decompose( this.camera.position, this.camera.quaternion, this.camera.scale );\n\t\t\tthis.camera.updateMatrix();\n\n\t\t\t//update camera up vector\n\t\t\tif ( this._state == STATE.ROTATE || this._state == STATE.ZROTATE || this._state == STATE.ANIMATION_ROTATE ) {\n\n\t\t\t\tthis.camera.up.copy( this._upState ).applyQuaternion( this.camera.quaternion );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( transformation.gizmos != null ) {\n\n\t\t\tthis._m4_1.copy( this._gizmoMatrixState ).premultiply( transformation.gizmos );\n\t\t\tthis._m4_1.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale );\n\t\t\tthis._gizmos.updateMatrix();\n\n\t\t}\n\n\t\tif ( this._state == STATE.SCALE || this._state == STATE.FOCUS || this._state == STATE.ANIMATION_FOCUS ) {\n\n\t\t\tthis._tbRadius = this.calculateTbRadius( this.camera );\n\n\t\t\tif ( this.adjustNearFar ) {\n\n\t\t\t\tconst cameraDistance = this.camera.position.distanceTo( this._gizmos.position );\n\n\t\t\t\tconst bb = new Box3();\n\t\t\t\tbb.setFromObject( this._gizmos );\n\t\t\t\tconst sphere = new Sphere();\n\t\t\t\tbb.getBoundingSphere( sphere );\n\n\t\t\t\tconst adjustedNearPosition = Math.max( this._nearPos0, sphere.radius + sphere.center.length() );\n\t\t\t\tconst regularNearPosition = cameraDistance - this._initialNear;\n\n\t\t\t\tconst minNearPos = Math.min( adjustedNearPosition, regularNearPosition );\n\t\t\t\tthis.camera.near = cameraDistance - minNearPos;\n\n\n\t\t\t\tconst adjustedFarPosition = Math.min( this._farPos0, - sphere.radius + sphere.center.length() );\n\t\t\t\tconst regularFarPosition = cameraDistance - this._initialFar;\n\n\t\t\t\tconst minFarPos = Math.min( adjustedFarPosition, regularFarPosition );\n\t\t\t\tthis.camera.far = cameraDistance - minFarPos;\n\n\t\t\t\tthis.camera.updateProjectionMatrix();\n\n\t\t\t} else {\n\n\t\t\t\tlet update = false;\n\n\t\t\t\tif ( this.camera.near != this._initialNear ) {\n\n\t\t\t\t\tthis.camera.near = this._initialNear;\n\t\t\t\t\tupdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.camera.far != this._initialFar ) {\n\n\t\t\t\t\tthis.camera.far = this._initialFar;\n\t\t\t\t\tupdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( update ) {\n\n\t\t\t\t\tthis.camera.updateProjectionMatrix();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Calculate the angular speed\n\t * @param {Number} p0 Position at t0\n\t * @param {Number} p1 Position at t1\n\t * @param {Number} t0 Initial time in milliseconds\n\t * @param {Number} t1 Ending time in milliseconds\n\t */\n\tcalculateAngularSpeed( p0, p1, t0, t1 ) {\n\n\t\tconst s = p1 - p0;\n\t\tconst t = ( t1 - t0 ) / 1000;\n\t\tif ( t == 0 ) {\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\treturn s / t;\n\n\t}\n\n\t/**\n\t * Calculate the distance between two pointers\n\t * @param {PointerEvent} p0 The first pointer\n\t * @param {PointerEvent} p1 The second pointer\n\t * @returns {number} The distance between the two pointers\n\t */\n\tcalculatePointersDistance( p0, p1 ) {\n\n\t\treturn Math.sqrt( Math.pow( p1.clientX - p0.clientX, 2 ) + Math.pow( p1.clientY - p0.clientY, 2 ) );\n\n\t}\n\n\t/**\n\t * Calculate the rotation axis as the vector perpendicular between two vectors\n\t * @param {Vector3} vec1 The first vector\n\t * @param {Vector3} vec2 The second vector\n\t * @returns {Vector3} The normalized rotation axis\n\t */\n\tcalculateRotationAxis( vec1, vec2 ) {\n\n\t\tthis._rotationMatrix.extractRotation( this._cameraMatrixState );\n\t\tthis._quat.setFromRotationMatrix( this._rotationMatrix );\n\n\t\tthis._rotationAxis.crossVectors( vec1, vec2 ).applyQuaternion( this._quat );\n\t\treturn this._rotationAxis.normalize().clone();\n\n\t}\n\n\t/**\n\t * Calculate the trackball radius so that gizmo's diamater will be 2/3 of the minimum side of the camera frustum\n\t * @param {Camera} camera\n\t * @returns {Number} The trackball radius\n\t */\n\tcalculateTbRadius( camera ) {\n\n\t\tconst distance = camera.position.distanceTo( this._gizmos.position );\n\n\t\tif ( camera.type == 'PerspectiveCamera' ) {\n\n\t\t\tconst halfFovV = MathUtils.DEG2RAD * camera.fov * 0.5; //vertical fov/2 in radians\n\t\t\tconst halfFovH = Math.atan( ( camera.aspect ) * Math.tan( halfFovV ) ); //horizontal fov/2 in radians\n\t\t\treturn Math.tan( Math.min( halfFovV, halfFovH ) ) * distance * this.radiusFactor;\n\n\t\t} else if ( camera.type == 'OrthographicCamera' ) {\n\n\t\t\treturn Math.min( camera.top, camera.right ) * this.radiusFactor;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Focus operation consist of positioning the point of interest in front of the camera and a slightly zoom in\n\t * @param {Vector3} point The point of interest\n\t * @param {Number} size Scale factor\n\t * @param {Number} amount Amount of operation to be completed (used for focus animations, default is complete full operation)\n\t */\n\tfocus( point, size, amount = 1 ) {\n\n\t\t//move center of camera (along with gizmos) towards point of interest\n\t\t_offset.copy( point ).sub( this._gizmos.position ).multiplyScalar( amount );\n\t\tthis._translationMatrix.makeTranslation( _offset.x, _offset.y, _offset.z );\n\n\t\t_gizmoMatrixStateTemp.copy( this._gizmoMatrixState );\n\t\tthis._gizmoMatrixState.premultiply( this._translationMatrix );\n\t\tthis._gizmoMatrixState.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale );\n\n\t\t_cameraMatrixStateTemp.copy( this._cameraMatrixState );\n\t\tthis._cameraMatrixState.premultiply( this._translationMatrix );\n\t\tthis._cameraMatrixState.decompose( this.camera.position, this.camera.quaternion, this.camera.scale );\n\n\t\t//apply zoom\n\t\tif ( this.enableZoom ) {\n\n\t\t\tthis.applyTransformMatrix( this.scale( size, this._gizmos.position ) );\n\n\t\t}\n\n\t\tthis._gizmoMatrixState.copy( _gizmoMatrixStateTemp );\n\t\tthis._cameraMatrixState.copy( _cameraMatrixStateTemp );\n\n\t}\n\n\t/**\n\t * Draw a grid and add it to the scene\n\t */\n\tdrawGrid() {\n\n\t\tif ( this.scene != null ) {\n\n\t\t\tconst color = 0x888888;\n\t\t\tconst multiplier = 3;\n\t\t\tlet size, divisions, maxLength, tick;\n\n\t\t\tif ( this.camera.isOrthographicCamera ) {\n\n\t\t\t\tconst width = this.camera.right - this.camera.left;\n\t\t\t\tconst height = this.camera.bottom - this.camera.top;\n\n\t\t\t\tmaxLength = Math.max( width, height );\n\t\t\t\ttick = maxLength / 20;\n\n\t\t\t\tsize = maxLength / this.camera.zoom * multiplier;\n\t\t\t\tdivisions = size / tick * this.camera.zoom;\n\n\t\t\t} else if ( this.camera.isPerspectiveCamera ) {\n\n\t\t\t\tconst distance = this.camera.position.distanceTo( this._gizmos.position );\n\t\t\t\tconst halfFovV = MathUtils.DEG2RAD * this.camera.fov * 0.5;\n\t\t\t\tconst halfFovH = Math.atan( ( this.camera.aspect ) * Math.tan( halfFovV ) );\n\n\t\t\t\tmaxLength = Math.tan( Math.max( halfFovV, halfFovH ) ) * distance * 2;\n\t\t\t\ttick = maxLength / 20;\n\n\t\t\t\tsize = maxLength * multiplier;\n\t\t\t\tdivisions = size / tick;\n\n\t\t\t}\n\n\t\t\tif ( this._grid == null ) {\n\n\t\t\t\tthis._grid = new GridHelper( size, divisions, color, color );\n\t\t\t\tthis._grid.position.copy( this._gizmos.position );\n\t\t\t\tthis._gridPosition.copy( this._grid.position );\n\t\t\t\tthis._grid.quaternion.copy( this.camera.quaternion );\n\t\t\t\tthis._grid.rotateX( Math.PI * 0.5 );\n\n\t\t\t\tthis.scene.add( this._grid );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Remove all listeners, stop animations and clean scene\n\t */\n\tdispose() {\n\n\t\tif ( this._animationId != - 1 ) {\n\n\t\t\twindow.cancelAnimationFrame( this._animationId );\n\n\t\t}\n\n\t\tthis.domElement.removeEventListener( 'pointerdown', this._onPointerDown );\n\t\tthis.domElement.removeEventListener( 'pointercancel', this._onPointerCancel );\n\t\tthis.domElement.removeEventListener( 'wheel', this._onWheel );\n\t\tthis.domElement.removeEventListener( 'contextmenu', this._onContextMenu );\n\n\t\twindow.removeEventListener( 'pointermove', this._onPointerMove );\n\t\twindow.removeEventListener( 'pointerup', this._onPointerUp );\n\n\t\twindow.removeEventListener( 'resize', this._onWindowResize );\n\n\t\tif ( this.scene !== null ) this.scene.remove( this._gizmos );\n\t\tthis.disposeGrid();\n\n\t}\n\n\t/**\n\t * remove the grid from the scene\n\t */\n\tdisposeGrid() {\n\n\t\tif ( this._grid != null && this.scene != null ) {\n\n\t\t\tthis.scene.remove( this._grid );\n\t\t\tthis._grid = null;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Compute the easing out cubic function for ease out effect in animation\n\t * @param {Number} t The absolute progress of the animation in the bound of 0 (beginning of the) and 1 (ending of animation)\n\t * @returns {Number} Result of easing out cubic at time t\n\t */\n\teaseOutCubic( t ) {\n\n\t\treturn 1 - Math.pow( 1 - t, 3 );\n\n\t}\n\n\t/**\n\t * Make rotation gizmos more or less visible\n\t * @param {Boolean} isActive If true, make gizmos more visible\n\t */\n\tactivateGizmos( isActive ) {\n\n\t\tconst gizmoX = this._gizmos.children[ 0 ];\n\t\tconst gizmoY = this._gizmos.children[ 1 ];\n\t\tconst gizmoZ = this._gizmos.children[ 2 ];\n\n\t\tif ( isActive ) {\n\n\t\t\tgizmoX.material.setValues( { opacity: 1 } );\n\t\t\tgizmoY.material.setValues( { opacity: 1 } );\n\t\t\tgizmoZ.material.setValues( { opacity: 1 } );\n\n\t\t} else {\n\n\t\t\tgizmoX.material.setValues( { opacity: 0.6 } );\n\t\t\tgizmoY.material.setValues( { opacity: 0.6 } );\n\t\t\tgizmoZ.material.setValues( { opacity: 0.6 } );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Calculate the cursor position in NDC\n\t * @param {number} x Cursor horizontal coordinate within the canvas\n\t * @param {number} y Cursor vertical coordinate within the canvas\n\t * @param {HTMLElement} canvas The canvas where the renderer draws its output\n\t * @returns {Vector2} Cursor normalized position inside the canvas\n\t */\n\tgetCursorNDC( cursorX, cursorY, canvas ) {\n\n\t\tconst canvasRect = canvas.getBoundingClientRect();\n\t\tthis._v2_1.setX( ( ( cursorX - canvasRect.left ) / canvasRect.width ) * 2 - 1 );\n\t\tthis._v2_1.setY( ( ( canvasRect.bottom - cursorY ) / canvasRect.height ) * 2 - 1 );\n\t\treturn this._v2_1.clone();\n\n\t}\n\n\t/**\n\t * Calculate the cursor position inside the canvas x/y coordinates with the origin being in the center of the canvas\n\t * @param {Number} x Cursor horizontal coordinate within the canvas\n\t * @param {Number} y Cursor vertical coordinate within the canvas\n\t * @param {HTMLElement} canvas The canvas where the renderer draws its output\n\t * @returns {Vector2} Cursor position inside the canvas\n\t */\n\tgetCursorPosition( cursorX, cursorY, canvas ) {\n\n\t\tthis._v2_1.copy( this.getCursorNDC( cursorX, cursorY, canvas ) );\n\t\tthis._v2_1.x *= ( this.camera.right - this.camera.left ) * 0.5;\n\t\tthis._v2_1.y *= ( this.camera.top - this.camera.bottom ) * 0.5;\n\t\treturn this._v2_1.clone();\n\n\t}\n\n\t/**\n\t * Set the camera to be controlled\n\t * @param {Camera} camera The virtual camera to be controlled\n\t */\n\tsetCamera( camera ) {\n\n\t\tcamera.lookAt( this.target );\n\t\tcamera.updateMatrix();\n\n\t\t//setting state\n\t\tif ( camera.type == 'PerspectiveCamera' ) {\n\n\t\t\tthis._fov0 = camera.fov;\n\t\t\tthis._fovState = camera.fov;\n\n\t\t}\n\n\t\tthis._cameraMatrixState0.copy( camera.matrix );\n\t\tthis._cameraMatrixState.copy( this._cameraMatrixState0 );\n\t\tthis._cameraProjectionState.copy( camera.projectionMatrix );\n\t\tthis._zoom0 = camera.zoom;\n\t\tthis._zoomState = this._zoom0;\n\n\t\tthis._initialNear = camera.near;\n\t\tthis._nearPos0 = camera.position.distanceTo( this.target ) - camera.near;\n\t\tthis._nearPos = this._initialNear;\n\n\t\tthis._initialFar = camera.far;\n\t\tthis._farPos0 = camera.position.distanceTo( this.target ) - camera.far;\n\t\tthis._farPos = this._initialFar;\n\n\t\tthis._up0.copy( camera.up );\n\t\tthis._upState.copy( camera.up );\n\n\t\tthis.camera = camera;\n\t\tthis.camera.updateProjectionMatrix();\n\n\t\t//making gizmos\n\t\tthis._tbRadius = this.calculateTbRadius( camera );\n\t\tthis.makeGizmos( this.target, this._tbRadius );\n\n\t}\n\n\t/**\n\t * Set gizmos visibility\n\t * @param {Boolean} value Value of gizmos visibility\n\t */\n\tsetGizmosVisible( value ) {\n\n\t\tthis._gizmos.visible = value;\n\t\tthis.dispatchEvent( _changeEvent );\n\n\t}\n\n\t/**\n\t * Set gizmos radius factor and redraws gizmos\n\t * @param {Float} value Value of radius factor\n\t */\n\tsetTbRadius( value ) {\n\n\t\tthis.radiusFactor = value;\n\t\tthis._tbRadius = this.calculateTbRadius( this.camera );\n\n\t\tconst curve = new EllipseCurve( 0, 0, this._tbRadius, this._tbRadius );\n\t\tconst points = curve.getPoints( this._curvePts );\n\t\tconst curveGeometry = new BufferGeometry().setFromPoints( points );\n\n\n\t\tfor ( const gizmo in this._gizmos.children ) {\n\n\t\t\tthis._gizmos.children[ gizmo ].geometry = curveGeometry;\n\n\t\t}\n\n\t\tthis.dispatchEvent( _changeEvent );\n\n\t}\n\n\t/**\n\t * Creates the rotation gizmos matching trackball center and radius\n\t * @param {Vector3} tbCenter The trackball center\n\t * @param {number} tbRadius The trackball radius\n\t */\n\tmakeGizmos( tbCenter, tbRadius ) {\n\n\t\tconst curve = new EllipseCurve( 0, 0, tbRadius, tbRadius );\n\t\tconst points = curve.getPoints( this._curvePts );\n\n\t\t//geometry\n\t\tconst curveGeometry = new BufferGeometry().setFromPoints( points );\n\n\t\t//material\n\t\tconst curveMaterialX = new LineBasicMaterial( { color: 0xff8080, fog: false, transparent: true, opacity: 0.6 } );\n\t\tconst curveMaterialY = new LineBasicMaterial( { color: 0x80ff80, fog: false, transparent: true, opacity: 0.6 } );\n\t\tconst curveMaterialZ = new LineBasicMaterial( { color: 0x8080ff, fog: false, transparent: true, opacity: 0.6 } );\n\n\t\t//line\n\t\tconst gizmoX = new Line( curveGeometry, curveMaterialX );\n\t\tconst gizmoY = new Line( curveGeometry, curveMaterialY );\n\t\tconst gizmoZ = new Line( curveGeometry, curveMaterialZ );\n\n\t\tconst rotation = Math.PI * 0.5;\n\t\tgizmoX.rotation.x = rotation;\n\t\tgizmoY.rotation.y = rotation;\n\n\n\t\t//setting state\n\t\tthis._gizmoMatrixState0.identity().setPosition( tbCenter );\n\t\tthis._gizmoMatrixState.copy( this._gizmoMatrixState0 );\n\n\t\tif ( this.camera.zoom !== 1 ) {\n\n\t\t\t//adapt gizmos size to camera zoom\n\t\t\tconst size = 1 / this.camera.zoom;\n\t\t\tthis._scaleMatrix.makeScale( size, size, size );\n\t\t\tthis._translationMatrix.makeTranslation( - tbCenter.x, - tbCenter.y, - tbCenter.z );\n\n\t\t\tthis._gizmoMatrixState.premultiply( this._translationMatrix ).premultiply( this._scaleMatrix );\n\t\t\tthis._translationMatrix.makeTranslation( tbCenter.x, tbCenter.y, tbCenter.z );\n\t\t\tthis._gizmoMatrixState.premultiply( this._translationMatrix );\n\n\t\t}\n\n\t\tthis._gizmoMatrixState.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale );\n\n\t\t//\n\n\t\tthis._gizmos.traverse( function ( object ) {\n\n\t\t\tif ( object.isLine ) {\n\n\t\t\t\tobject.geometry.dispose();\n\t\t\t\tobject.material.dispose();\n\n\t\t\t}\n\n\t\t} );\n\n\t\tthis._gizmos.clear();\n\n\t\t//\n\n\t\tthis._gizmos.add( gizmoX );\n\t\tthis._gizmos.add( gizmoY );\n\t\tthis._gizmos.add( gizmoZ );\n\n\t}\n\n\t/**\n\t * Perform animation for focus operation\n\t * @param {Number} time Instant in which this function is called as performance.now()\n\t * @param {Vector3} point Point of interest for focus operation\n\t * @param {Matrix4} cameraMatrix Camera matrix\n\t * @param {Matrix4} gizmoMatrix Gizmos matrix\n\t */\n\tonFocusAnim( time, point, cameraMatrix, gizmoMatrix ) {\n\n\t\tif ( this._timeStart == - 1 ) {\n\n\t\t\t//animation start\n\t\t\tthis._timeStart = time;\n\n\t\t}\n\n\t\tif ( this._state == STATE.ANIMATION_FOCUS ) {\n\n\t\t\tconst deltaTime = time - this._timeStart;\n\t\t\tconst animTime = deltaTime / this.focusAnimationTime;\n\n\t\t\tthis._gizmoMatrixState.copy( gizmoMatrix );\n\n\t\t\tif ( animTime >= 1 ) {\n\n\t\t\t\t//animation end\n\n\t\t\t\tthis._gizmoMatrixState.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale );\n\n\t\t\t\tthis.focus( point, this.scaleFactor );\n\n\t\t\t\tthis._timeStart = - 1;\n\t\t\t\tthis.updateTbState( STATE.IDLE, false );\n\t\t\t\tthis.activateGizmos( false );\n\n\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t} else {\n\n\t\t\t\tconst amount = this.easeOutCubic( animTime );\n\t\t\t\tconst size = ( ( 1 - amount ) + ( this.scaleFactor * amount ) );\n\n\t\t\t\tthis._gizmoMatrixState.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale );\n\t\t\t\tthis.focus( point, size, amount );\n\n\t\t\t\tthis.dispatchEvent( _changeEvent );\n\t\t\t\tconst self = this;\n\t\t\t\tthis._animationId = window.requestAnimationFrame( function ( t ) {\n\n\t\t\t\t\tself.onFocusAnim( t, point, cameraMatrix, gizmoMatrix.clone() );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t//interrupt animation\n\n\t\t\tthis._animationId = - 1;\n\t\t\tthis._timeStart = - 1;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Perform animation for rotation operation\n\t * @param {Number} time Instant in which this function is called as performance.now()\n\t * @param {Vector3} rotationAxis Rotation axis\n\t * @param {number} w0 Initial angular velocity\n\t */\n\tonRotationAnim( time, rotationAxis, w0 ) {\n\n\t\tif ( this._timeStart == - 1 ) {\n\n\t\t\t//animation start\n\t\t\tthis._anglePrev = 0;\n\t\t\tthis._angleCurrent = 0;\n\t\t\tthis._timeStart = time;\n\n\t\t}\n\n\t\tif ( this._state == STATE.ANIMATION_ROTATE ) {\n\n\t\t\t//w = w0 + alpha * t\n\t\t\tconst deltaTime = ( time - this._timeStart ) / 1000;\n\t\t\tconst w = w0 + ( ( - this.dampingFactor ) * deltaTime );\n\n\t\t\tif ( w > 0 ) {\n\n\t\t\t\t//tetha = 0.5 * alpha * t^2 + w0 * t + tetha0\n\t\t\t\tthis._angleCurrent = 0.5 * ( - this.dampingFactor ) * Math.pow( deltaTime, 2 ) + w0 * deltaTime + 0;\n\t\t\t\tthis.applyTransformMatrix( this.rotate( rotationAxis, this._angleCurrent ) );\n\t\t\t\tthis.dispatchEvent( _changeEvent );\n\t\t\t\tconst self = this;\n\t\t\t\tthis._animationId = window.requestAnimationFrame( function ( t ) {\n\n\t\t\t\t\tself.onRotationAnim( t, rotationAxis, w0 );\n\n\t\t\t\t} );\n\n\t\t\t} else {\n\n\t\t\t\tthis._animationId = - 1;\n\t\t\t\tthis._timeStart = - 1;\n\n\t\t\t\tthis.updateTbState( STATE.IDLE, false );\n\t\t\t\tthis.activateGizmos( false );\n\n\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t//interrupt animation\n\n\t\t\tthis._animationId = - 1;\n\t\t\tthis._timeStart = - 1;\n\n\t\t\tif ( this._state != STATE.ROTATE ) {\n\n\t\t\t\tthis.activateGizmos( false );\n\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\t/**\n\t * Perform pan operation moving camera between two points\n\t * @param {Vector3} p0 Initial point\n\t * @param {Vector3} p1 Ending point\n\t * @param {Boolean} adjust If movement should be adjusted considering camera distance (Perspective only)\n\t */\n\tpan( p0, p1, adjust = false ) {\n\n\t\tconst movement = p0.clone().sub( p1 );\n\n\t\tif ( this.camera.isOrthographicCamera ) {\n\n\t\t\t//adjust movement amount\n\t\t\tmovement.multiplyScalar( 1 / this.camera.zoom );\n\n\t\t} else if ( this.camera.isPerspectiveCamera && adjust ) {\n\n\t\t\t//adjust movement amount\n\t\t\tthis._v3_1.setFromMatrixPosition( this._cameraMatrixState0 );\t//camera's initial position\n\t\t\tthis._v3_2.setFromMatrixPosition( this._gizmoMatrixState0 );\t//gizmo's initial position\n\t\t\tconst distanceFactor = this._v3_1.distanceTo( this._v3_2 ) / this.camera.position.distanceTo( this._gizmos.position );\n\t\t\tmovement.multiplyScalar( 1 / distanceFactor );\n\n\t\t}\n\n\t\tthis._v3_1.set( movement.x, movement.y, 0 ).applyQuaternion( this.camera.quaternion );\n\n\t\tthis._m4_1.makeTranslation( this._v3_1.x, this._v3_1.y, this._v3_1.z );\n\n\t\tthis.setTransformationMatrices( this._m4_1, this._m4_1 );\n\t\treturn _transformation;\n\n\t}\n\n\t/**\n\t * Reset trackball\n\t */\n\treset() {\n\n\t\tthis.camera.zoom = this._zoom0;\n\n\t\tif ( this.camera.isPerspectiveCamera ) {\n\n\t\t\tthis.camera.fov = this._fov0;\n\n\t\t}\n\n\t\tthis.camera.near = this._nearPos;\n\t\tthis.camera.far = this._farPos;\n\t\tthis._cameraMatrixState.copy( this._cameraMatrixState0 );\n\t\tthis._cameraMatrixState.decompose( this.camera.position, this.camera.quaternion, this.camera.scale );\n\t\tthis.camera.up.copy( this._up0 );\n\n\t\tthis.camera.updateMatrix();\n\t\tthis.camera.updateProjectionMatrix();\n\n\t\tthis._gizmoMatrixState.copy( this._gizmoMatrixState0 );\n\t\tthis._gizmoMatrixState0.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale );\n\t\tthis._gizmos.updateMatrix();\n\n\t\tthis._tbRadius = this.calculateTbRadius( this.camera );\n\t\tthis.makeGizmos( this._gizmos.position, this._tbRadius );\n\n\t\tthis.camera.lookAt( this._gizmos.position );\n\n\t\tthis.updateTbState( STATE.IDLE, false );\n\n\t\tthis.dispatchEvent( _changeEvent );\n\n\t}\n\n\t/**\n\t * Rotate the camera around an axis passing by trackball's center\n\t * @param {Vector3} axis Rotation axis\n\t * @param {number} angle Angle in radians\n\t * @returns {Object} Object with 'camera' field containing transformation matrix resulting from the operation to be applied to the camera\n\t */\n\trotate( axis, angle ) {\n\n\t\tconst point = this._gizmos.position; //rotation center\n\t\tthis._translationMatrix.makeTranslation( - point.x, - point.y, - point.z );\n\t\tthis._rotationMatrix.makeRotationAxis( axis, - angle );\n\n\t\t//rotate camera\n\t\tthis._m4_1.makeTranslation( point.x, point.y, point.z );\n\t\tthis._m4_1.multiply( this._rotationMatrix );\n\t\tthis._m4_1.multiply( this._translationMatrix );\n\n\t\tthis.setTransformationMatrices( this._m4_1 );\n\n\t\treturn _transformation;\n\n\t}\n\n\tcopyState() {\n\n\t\tlet state;\n\t\tif ( this.camera.isOrthographicCamera ) {\n\n\t\t\tstate = JSON.stringify( { arcballState: {\n\n\t\t\t\tcameraFar: this.camera.far,\n\t\t\t\tcameraMatrix: this.camera.matrix,\n\t\t\t\tcameraNear: this.camera.near,\n\t\t\t\tcameraUp: this.camera.up,\n\t\t\t\tcameraZoom: this.camera.zoom,\n\t\t\t\tgizmoMatrix: this._gizmos.matrix\n\n\t\t\t} } );\n\n\t\t} else if ( this.camera.isPerspectiveCamera ) {\n\n\t\t\tstate = JSON.stringify( { arcballState: {\n\t\t\t\tcameraFar: this.camera.far,\n\t\t\t\tcameraFov: this.camera.fov,\n\t\t\t\tcameraMatrix: this.camera.matrix,\n\t\t\t\tcameraNear: this.camera.near,\n\t\t\t\tcameraUp: this.camera.up,\n\t\t\t\tcameraZoom: this.camera.zoom,\n\t\t\t\tgizmoMatrix: this._gizmos.matrix\n\n\t\t\t} } );\n\n\t\t}\n\n\t\tnavigator.clipboard.writeText( state );\n\n\t}\n\n\tpasteState() {\n\n\t\tconst self = this;\n\t\tnavigator.clipboard.readText().then( function resolved( value ) {\n\n\t\t\tself.setStateFromJSON( value );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Save the current state of the control. This can later be recover with .reset\n\t */\n\tsaveState() {\n\n\t\tthis._cameraMatrixState0.copy( this.camera.matrix );\n\t\tthis._gizmoMatrixState0.copy( this._gizmos.matrix );\n\t\tthis._nearPos = this.camera.near;\n\t\tthis._farPos = this.camera.far;\n\t\tthis._zoom0 = this.camera.zoom;\n\t\tthis._up0.copy( this.camera.up );\n\n\t\tif ( this.camera.isPerspectiveCamera ) {\n\n\t\t\tthis._fov0 = this.camera.fov;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Perform uniform scale operation around a given point\n\t * @param {Number} size Scale factor\n\t * @param {Vector3} point Point around which scale\n\t * @param {Boolean} scaleGizmos If gizmos should be scaled (Perspective only)\n\t * @returns {Object} Object with 'camera' and 'gizmo' fields containing transformation matrices resulting from the operation to be applied to the camera and gizmos\n\t */\n\tscale( size, point, scaleGizmos = true ) {\n\n\t\t_scalePointTemp.copy( point );\n\t\tlet sizeInverse = 1 / size;\n\n\t\tif ( this.camera.isOrthographicCamera ) {\n\n\t\t\t//camera zoom\n\t\t\tthis.camera.zoom = this._zoomState;\n\t\t\tthis.camera.zoom *= size;\n\n\t\t\t//check min and max zoom\n\t\t\tif ( this.camera.zoom > this.maxZoom ) {\n\n\t\t\t\tthis.camera.zoom = this.maxZoom;\n\t\t\t\tsizeInverse = this._zoomState / this.maxZoom;\n\n\t\t\t} else if ( this.camera.zoom < this.minZoom ) {\n\n\t\t\t\tthis.camera.zoom = this.minZoom;\n\t\t\t\tsizeInverse = this._zoomState / this.minZoom;\n\n\t\t\t}\n\n\t\t\tthis.camera.updateProjectionMatrix();\n\n\t\t\tthis._v3_1.setFromMatrixPosition( this._gizmoMatrixState );\t//gizmos position\n\n\t\t\t//scale gizmos so they appear in the same spot having the same dimension\n\t\t\tthis._scaleMatrix.makeScale( sizeInverse, sizeInverse, sizeInverse );\n\t\t\tthis._translationMatrix.makeTranslation( - this._v3_1.x, - this._v3_1.y, - this._v3_1.z );\n\n\t\t\tthis._m4_2.makeTranslation( this._v3_1.x, this._v3_1.y, this._v3_1.z ).multiply( this._scaleMatrix );\n\t\t\tthis._m4_2.multiply( this._translationMatrix );\n\n\n\t\t\t//move camera and gizmos to obtain pinch effect\n\t\t\t_scalePointTemp.sub( this._v3_1 );\n\n\t\t\tconst amount = _scalePointTemp.clone().multiplyScalar( sizeInverse );\n\t\t\t_scalePointTemp.sub( amount );\n\n\t\t\tthis._m4_1.makeTranslation( _scalePointTemp.x, _scalePointTemp.y, _scalePointTemp.z );\n\t\t\tthis._m4_2.premultiply( this._m4_1 );\n\n\t\t\tthis.setTransformationMatrices( this._m4_1, this._m4_2 );\n\t\t\treturn _transformation;\n\n\t\t} else if ( this.camera.isPerspectiveCamera ) {\n\n\t\t\tthis._v3_1.setFromMatrixPosition( this._cameraMatrixState );\n\t\t\tthis._v3_2.setFromMatrixPosition( this._gizmoMatrixState );\n\n\t\t\t//move camera\n\t\t\tlet distance = this._v3_1.distanceTo( _scalePointTemp );\n\t\t\tlet amount = distance - ( distance * sizeInverse );\n\n\t\t\t//check min and max distance\n\t\t\tconst newDistance = distance - amount;\n\t\t\tif ( newDistance < this.minDistance ) {\n\n\t\t\t\tsizeInverse = this.minDistance / distance;\n\t\t\t\tamount = distance - ( distance * sizeInverse );\n\n\t\t\t} else if ( newDistance > this.maxDistance ) {\n\n\t\t\t\tsizeInverse = this.maxDistance / distance;\n\t\t\t\tamount = distance - ( distance * sizeInverse );\n\n\t\t\t}\n\n\t\t\t_offset.copy( _scalePointTemp ).sub( this._v3_1 ).normalize().multiplyScalar( amount );\n\n\t\t\tthis._m4_1.makeTranslation( _offset.x, _offset.y, _offset.z );\n\n\n\t\t\tif ( scaleGizmos ) {\n\n\t\t\t\t//scale gizmos so they appear in the same spot having the same dimension\n\t\t\t\tconst pos = this._v3_2;\n\n\t\t\t\tdistance = pos.distanceTo( _scalePointTemp );\n\t\t\t\tamount = distance - ( distance * sizeInverse );\n\t\t\t\t_offset.copy( _scalePointTemp ).sub( this._v3_2 ).normalize().multiplyScalar( amount );\n\n\t\t\t\tthis._translationMatrix.makeTranslation( pos.x, pos.y, pos.z );\n\t\t\t\tthis._scaleMatrix.makeScale( sizeInverse, sizeInverse, sizeInverse );\n\n\t\t\t\tthis._m4_2.makeTranslation( _offset.x, _offset.y, _offset.z ).multiply( this._translationMatrix );\n\t\t\t\tthis._m4_2.multiply( this._scaleMatrix );\n\n\t\t\t\tthis._translationMatrix.makeTranslation( - pos.x, - pos.y, - pos.z );\n\n\t\t\t\tthis._m4_2.multiply( this._translationMatrix );\n\t\t\t\tthis.setTransformationMatrices( this._m4_1, this._m4_2 );\n\n\n\t\t\t} else {\n\n\t\t\t\tthis.setTransformationMatrices( this._m4_1 );\n\n\t\t\t}\n\n\t\t\treturn _transformation;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Set camera fov\n\t * @param {Number} value fov to be setted\n\t */\n\tsetFov( value ) {\n\n\t\tif ( this.camera.isPerspectiveCamera ) {\n\n\t\t\tthis.camera.fov = MathUtils.clamp( value, this.minFov, this.maxFov );\n\t\t\tthis.camera.updateProjectionMatrix();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Set values in transformation object\n\t * @param {Matrix4} camera Transformation to be applied to the camera\n\t * @param {Matrix4} gizmos Transformation to be applied to gizmos\n\t */\n\t setTransformationMatrices( camera = null, gizmos = null ) {\n\n\t\tif ( camera != null ) {\n\n\t\t\tif ( _transformation.camera != null ) {\n\n\t\t\t\t_transformation.camera.copy( camera );\n\n\t\t\t} else {\n\n\t\t\t\t_transformation.camera = camera.clone();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t_transformation.camera = null;\n\n\t\t}\n\n\t\tif ( gizmos != null ) {\n\n\t\t\tif ( _transformation.gizmos != null ) {\n\n\t\t\t\t_transformation.gizmos.copy( gizmos );\n\n\t\t\t} else {\n\n\t\t\t\t_transformation.gizmos = gizmos.clone();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t_transformation.gizmos = null;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Rotate camera around its direction axis passing by a given point by a given angle\n\t * @param {Vector3} point The point where the rotation axis is passing trough\n\t * @param {Number} angle Angle in radians\n\t * @returns The computed transormation matix\n\t */\n\tzRotate( point, angle ) {\n\n\t\tthis._rotationMatrix.makeRotationAxis( this._rotationAxis, angle );\n\t\tthis._translationMatrix.makeTranslation( - point.x, - point.y, - point.z );\n\n\t\tthis._m4_1.makeTranslation( point.x, point.y, point.z );\n\t\tthis._m4_1.multiply( this._rotationMatrix );\n\t\tthis._m4_1.multiply( this._translationMatrix );\n\n\t\tthis._v3_1.setFromMatrixPosition( this._gizmoMatrixState ).sub( point );\t//vector from rotation center to gizmos position\n\t\tthis._v3_2.copy( this._v3_1 ).applyAxisAngle( this._rotationAxis, angle );\t//apply rotation\n\t\tthis._v3_2.sub( this._v3_1 );\n\n\t\tthis._m4_2.makeTranslation( this._v3_2.x, this._v3_2.y, this._v3_2.z );\n\n\t\tthis.setTransformationMatrices( this._m4_1, this._m4_2 );\n\t\treturn _transformation;\n\n\t}\n\n\n\tgetRaycaster() {\n\n\t\treturn _raycaster;\n\n\t}\n\n\n\t/**\n\t * Unproject the cursor on the 3D object surface\n\t * @param {Vector2} cursor Cursor coordinates in NDC\n\t * @param {Camera} camera Virtual camera\n\t * @returns {Vector3} The point of intersection with the model, if exist, null otherwise\n\t */\n\tunprojectOnObj( cursor, camera ) {\n\n\t\tconst raycaster = this.getRaycaster();\n\t\traycaster.near = camera.near;\n\t\traycaster.far = camera.far;\n\t\traycaster.setFromCamera( cursor, camera );\n\n\t\tconst intersect = raycaster.intersectObjects( this.scene.children, true );\n\n\t\tfor ( let i = 0; i < intersect.length; i ++ ) {\n\n\t\t\tif ( intersect[ i ].object.uuid != this._gizmos.uuid && intersect[ i ].face != null ) {\n\n\t\t\t\treturn intersect[ i ].point.clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t/**\n\t * Unproject the cursor on the trackball surface\n\t * @param {Camera} camera The virtual camera\n\t * @param {Number} cursorX Cursor horizontal coordinate on screen\n\t * @param {Number} cursorY Cursor vertical coordinate on screen\n\t * @param {HTMLElement} canvas The canvas where the renderer draws its output\n\t * @param {number} tbRadius The trackball radius\n\t * @returns {Vector3} The unprojected point on the trackball surface\n\t */\n\tunprojectOnTbSurface( camera, cursorX, cursorY, canvas, tbRadius ) {\n\n\t\tif ( camera.type == 'OrthographicCamera' ) {\n\n\t\t\tthis._v2_1.copy( this.getCursorPosition( cursorX, cursorY, canvas ) );\n\t\t\tthis._v3_1.set( this._v2_1.x, this._v2_1.y, 0 );\n\n\t\t\tconst x2 = Math.pow( this._v2_1.x, 2 );\n\t\t\tconst y2 = Math.pow( this._v2_1.y, 2 );\n\t\t\tconst r2 = Math.pow( this._tbRadius, 2 );\n\n\t\t\tif ( x2 + y2 <= r2 * 0.5 ) {\n\n\t\t\t\t//intersection with sphere\n\t\t\t\tthis._v3_1.setZ( Math.sqrt( r2 - ( x2 + y2 ) ) );\n\n\t\t\t} else {\n\n\t\t\t\t//intersection with hyperboloid\n\t\t\t\tthis._v3_1.setZ( ( r2 * 0.5 ) / ( Math.sqrt( x2 + y2 ) ) );\n\n\t\t\t}\n\n\t\t\treturn this._v3_1;\n\n\t\t} else if ( camera.type == 'PerspectiveCamera' ) {\n\n\t\t\t//unproject cursor on the near plane\n\t\t\tthis._v2_1.copy( this.getCursorNDC( cursorX, cursorY, canvas ) );\n\n\t\t\tthis._v3_1.set( this._v2_1.x, this._v2_1.y, - 1 );\n\t\t\tthis._v3_1.applyMatrix4( camera.projectionMatrixInverse );\n\n\t\t\tconst rayDir = this._v3_1.clone().normalize(); //unprojected ray direction\n\t\t\tconst cameraGizmoDistance = camera.position.distanceTo( this._gizmos.position );\n\t\t\tconst radius2 = Math.pow( tbRadius, 2 );\n\n\t\t\t//\t  camera\n\t\t\t//\t\t|\\\n\t\t\t//\t\t| \\\n\t\t\t//\t\t|  \\\n\t\t\t//\th\t|\t\\\n\t\t\t//\t\t| \t \\\n\t\t\t//\t\t| \t  \\\n\t\t\t//\t_ _ | _ _ _\\ _ _  near plane\n\t\t\t//\t\t\tl\n\n\t\t\tconst h = this._v3_1.z;\n\t\t\tconst l = Math.sqrt( Math.pow( this._v3_1.x, 2 ) + Math.pow( this._v3_1.y, 2 ) );\n\n\t\t\tif ( l == 0 ) {\n\n\t\t\t\t//ray aligned with camera\n\t\t\t\trayDir.set( this._v3_1.x, this._v3_1.y, tbRadius );\n\t\t\t\treturn rayDir;\n\n\t\t\t}\n\n\t\t\tconst m = h / l;\n\t\t\tconst q = cameraGizmoDistance;\n\n\t\t\t/*\n\t\t\t * calculate intersection point between unprojected ray and trackball surface\n\t\t\t *|y = m * x + q\n\t\t\t *|x^2 + y^2 = r^2\n\t\t\t *\n\t\t\t * (m^2 + 1) * x^2 + (2 * m * q) * x + q^2 - r^2 = 0\n\t\t\t */\n\t\t\tlet a = Math.pow( m, 2 ) + 1;\n\t\t\tlet b = 2 * m * q;\n\t\t\tlet c = Math.pow( q, 2 ) - radius2;\n\t\t\tlet delta = Math.pow( b, 2 ) - ( 4 * a * c );\n\n\t\t\tif ( delta >= 0 ) {\n\n\t\t\t\t//intersection with sphere\n\t\t\t\tthis._v2_1.setX( ( - b - Math.sqrt( delta ) ) / ( 2 * a ) );\n\t\t\t\tthis._v2_1.setY( m * this._v2_1.x + q );\n\n\t\t\t\tconst angle = MathUtils.RAD2DEG * this._v2_1.angle();\n\n\t\t\t\tif ( angle >= 45 ) {\n\n\t\t\t\t\t//if angle between intersection point and X' axis is >= 45°, return that point\n\t\t\t\t\t//otherwise, calculate intersection point with hyperboloid\n\n\t\t\t\t\tconst rayLength = Math.sqrt( Math.pow( this._v2_1.x, 2 ) + Math.pow( ( cameraGizmoDistance - this._v2_1.y ), 2 ) );\n\t\t\t\t\trayDir.multiplyScalar( rayLength );\n\t\t\t\t\trayDir.z += cameraGizmoDistance;\n\t\t\t\t\treturn rayDir;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//intersection with hyperboloid\n\t\t\t/*\n\t\t\t *|y = m * x + q\n\t\t\t *|y = (1 / x) * (r^2 / 2)\n\t\t\t *\n\t\t\t * m * x^2 + q * x - r^2 / 2 = 0\n\t\t\t */\n\n\t\t\ta = m;\n\t\t\tb = q;\n\t\t\tc = - radius2 * 0.5;\n\t\t\tdelta = Math.pow( b, 2 ) - ( 4 * a * c );\n\t\t\tthis._v2_1.setX( ( - b - Math.sqrt( delta ) ) / ( 2 * a ) );\n\t\t\tthis._v2_1.setY( m * this._v2_1.x + q );\n\n\t\t\tconst rayLength = Math.sqrt( Math.pow( this._v2_1.x, 2 ) + Math.pow( ( cameraGizmoDistance - this._v2_1.y ), 2 ) );\n\n\t\t\trayDir.multiplyScalar( rayLength );\n\t\t\trayDir.z += cameraGizmoDistance;\n\t\t\treturn rayDir;\n\n\t\t}\n\n\t}\n\n\n\t/**\n\t * Unproject the cursor on the plane passing through the center of the trackball orthogonal to the camera\n\t * @param {Camera} camera The virtual camera\n\t * @param {Number} cursorX Cursor horizontal coordinate on screen\n\t * @param {Number} cursorY Cursor vertical coordinate on screen\n\t * @param {HTMLElement} canvas The canvas where the renderer draws its output\n\t * @param {Boolean} initialDistance If initial distance between camera and gizmos should be used for calculations instead of current (Perspective only)\n\t * @returns {Vector3} The unprojected point on the trackball plane\n\t */\n\tunprojectOnTbPlane( camera, cursorX, cursorY, canvas, initialDistance = false ) {\n\n\t\tif ( camera.type == 'OrthographicCamera' ) {\n\n\t\t\tthis._v2_1.copy( this.getCursorPosition( cursorX, cursorY, canvas ) );\n\t\t\tthis._v3_1.set( this._v2_1.x, this._v2_1.y, 0 );\n\n\t\t\treturn this._v3_1.clone();\n\n\t\t} else if ( camera.type == 'PerspectiveCamera' ) {\n\n\t\t\tthis._v2_1.copy( this.getCursorNDC( cursorX, cursorY, canvas ) );\n\n\t\t\t//unproject cursor on the near plane\n\t\t\tthis._v3_1.set( this._v2_1.x, this._v2_1.y, - 1 );\n\t\t\tthis._v3_1.applyMatrix4( camera.projectionMatrixInverse );\n\n\t\t\tconst rayDir = this._v3_1.clone().normalize(); //unprojected ray direction\n\n\t\t\t//\t  camera\n\t\t\t//\t\t|\\\n\t\t\t//\t\t| \\\n\t\t\t//\t\t|  \\\n\t\t\t//\th\t|\t\\\n\t\t\t//\t\t| \t \\\n\t\t\t//\t\t| \t  \\\n\t\t\t//\t_ _ | _ _ _\\ _ _  near plane\n\t\t\t//\t\t\tl\n\n\t\t\tconst h = this._v3_1.z;\n\t\t\tconst l = Math.sqrt( Math.pow( this._v3_1.x, 2 ) + Math.pow( this._v3_1.y, 2 ) );\n\t\t\tlet cameraGizmoDistance;\n\n\t\t\tif ( initialDistance ) {\n\n\t\t\t\tcameraGizmoDistance = this._v3_1.setFromMatrixPosition( this._cameraMatrixState0 ).distanceTo( this._v3_2.setFromMatrixPosition( this._gizmoMatrixState0 ) );\n\n\t\t\t} else {\n\n\t\t\t\tcameraGizmoDistance = camera.position.distanceTo( this._gizmos.position );\n\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * calculate intersection point between unprojected ray and the plane\n\t\t\t *|y = mx + q\n\t\t\t *|y = 0\n\t\t\t *\n\t\t\t * x = -q/m\n\t\t\t*/\n\t\t\tif ( l == 0 ) {\n\n\t\t\t\t//ray aligned with camera\n\t\t\t\trayDir.set( 0, 0, 0 );\n\t\t\t\treturn rayDir;\n\n\t\t\t}\n\n\t\t\tconst m = h / l;\n\t\t\tconst q = cameraGizmoDistance;\n\t\t\tconst x = - q / m;\n\n\t\t\tconst rayLength = Math.sqrt( Math.pow( q, 2 ) + Math.pow( x, 2 ) );\n\t\t\trayDir.multiplyScalar( rayLength );\n\t\t\trayDir.z = 0;\n\t\t\treturn rayDir;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Update camera and gizmos state\n\t */\n\tupdateMatrixState() {\n\n\t\t//update camera and gizmos state\n\t\tthis._cameraMatrixState.copy( this.camera.matrix );\n\t\tthis._gizmoMatrixState.copy( this._gizmos.matrix );\n\n\t\tif ( this.camera.isOrthographicCamera ) {\n\n\t\t\tthis._cameraProjectionState.copy( this.camera.projectionMatrix );\n\t\t\tthis.camera.updateProjectionMatrix();\n\t\t\tthis._zoomState = this.camera.zoom;\n\n\t\t} else if ( this.camera.isPerspectiveCamera ) {\n\n\t\t\tthis._fovState = this.camera.fov;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Update the trackball FSA\n\t * @param {STATE} newState New state of the FSA\n\t * @param {Boolean} updateMatrices If matriices state should be updated\n\t */\n\tupdateTbState( newState, updateMatrices ) {\n\n\t\tthis._state = newState;\n\t\tif ( updateMatrices ) {\n\n\t\t\tthis.updateMatrixState();\n\n\t\t}\n\n\t}\n\n\tupdate() {\n\n\t\tconst EPS = 0.000001;\n\n\t\tif ( this.target.equals( this._currentTarget ) === false ) {\n\n\t\t\tthis._gizmos.position.copy( this.target );\t//for correct radius calculation\n\t\t\tthis._tbRadius = this.calculateTbRadius( this.camera );\n\t\t\tthis.makeGizmos( this.target, this._tbRadius );\n\t\t\tthis._currentTarget.copy( this.target );\n\n\t\t}\n\n\t\t//check min/max parameters\n\t\tif ( this.camera.isOrthographicCamera ) {\n\n\t\t\t//check zoom\n\t\t\tif ( this.camera.zoom > this.maxZoom || this.camera.zoom < this.minZoom ) {\n\n\t\t\t\tconst newZoom = MathUtils.clamp( this.camera.zoom, this.minZoom, this.maxZoom );\n\t\t\t\tthis.applyTransformMatrix( this.scale( newZoom / this.camera.zoom, this._gizmos.position, true ) );\n\n\t\t\t}\n\n\t\t} else if ( this.camera.isPerspectiveCamera ) {\n\n\t\t\t//check distance\n\t\t\tconst distance = this.camera.position.distanceTo( this._gizmos.position );\n\n\t\t\tif ( distance > this.maxDistance + EPS || distance < this.minDistance - EPS ) {\n\n\t\t\t\tconst newDistance = MathUtils.clamp( distance, this.minDistance, this.maxDistance );\n\t\t\t\tthis.applyTransformMatrix( this.scale( newDistance / distance, this._gizmos.position ) );\n\t\t\t\tthis.updateMatrixState();\n\n\t\t\t }\n\n\t\t\t//check fov\n\t\t\tif ( this.camera.fov < this.minFov || this.camera.fov > this.maxFov ) {\n\n\t\t\t\tthis.camera.fov = MathUtils.clamp( this.camera.fov, this.minFov, this.maxFov );\n\t\t\t\tthis.camera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tconst oldRadius = this._tbRadius;\n\t\t\tthis._tbRadius = this.calculateTbRadius( this.camera );\n\n\t\t\tif ( oldRadius < this._tbRadius - EPS || oldRadius > this._tbRadius + EPS ) {\n\n\t\t\t\tconst scale = ( this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z ) / 3;\n\t\t\t\tconst newRadius = this._tbRadius / scale;\n\t\t\t\tconst curve = new EllipseCurve( 0, 0, newRadius, newRadius );\n\t\t\t\tconst points = curve.getPoints( this._curvePts );\n\t\t\t\tconst curveGeometry = new BufferGeometry().setFromPoints( points );\n\n\t\t\t\tfor ( const gizmo in this._gizmos.children ) {\n\n\t\t\t\t\tthis._gizmos.children[ gizmo ].geometry = curveGeometry;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.camera.lookAt( this._gizmos.position );\n\n\t}\n\n\tsetStateFromJSON( json ) {\n\n\t\tconst state = JSON.parse( json );\n\n\t\tif ( state.arcballState != undefined ) {\n\n\t\t\tthis._cameraMatrixState.fromArray( state.arcballState.cameraMatrix.elements );\n\t\t\tthis._cameraMatrixState.decompose( this.camera.position, this.camera.quaternion, this.camera.scale );\n\n\t\t\tthis.camera.up.copy( state.arcballState.cameraUp );\n\t\t\tthis.camera.near = state.arcballState.cameraNear;\n\t\t\tthis.camera.far = state.arcballState.cameraFar;\n\n\t\t\tthis.camera.zoom = state.arcballState.cameraZoom;\n\n\t\t\tif ( this.camera.isPerspectiveCamera ) {\n\n\t\t\t\tthis.camera.fov = state.arcballState.cameraFov;\n\n\t\t\t}\n\n\t\t\tthis._gizmoMatrixState.fromArray( state.arcballState.gizmoMatrix.elements );\n\t\t\tthis._gizmoMatrixState.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale );\n\n\t\t\tthis.camera.updateMatrix();\n\t\t\tthis.camera.updateProjectionMatrix();\n\n\t\t\tthis._gizmos.updateMatrix();\n\n\t\t\tthis._tbRadius = this.calculateTbRadius( this.camera );\n\t\t\tconst gizmoTmp = new Matrix4().copy( this._gizmoMatrixState0 );\n\t\t\tthis.makeGizmos( this._gizmos.position, this._tbRadius );\n\t\t\tthis._gizmoMatrixState0.copy( gizmoTmp );\n\n\t\t\tthis.camera.lookAt( this._gizmos.position );\n\t\t\tthis.updateTbState( STATE.IDLE, false );\n\n\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t}\n\n\t}\n\n}\n\n//listeners\n\nfunction onWindowResize() {\n\n\tconst scale = ( this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z ) / 3;\n\tthis._tbRadius = this.calculateTbRadius( this.camera );\n\n\tconst newRadius = this._tbRadius / scale;\n\tconst curve = new EllipseCurve( 0, 0, newRadius, newRadius );\n\tconst points = curve.getPoints( this._curvePts );\n\tconst curveGeometry = new BufferGeometry().setFromPoints( points );\n\n\n\tfor ( const gizmo in this._gizmos.children ) {\n\n\t\tthis._gizmos.children[ gizmo ].geometry = curveGeometry;\n\n\t}\n\n\tthis.dispatchEvent( _changeEvent );\n\n}\n\nfunction onContextMenu( event ) {\n\n\tif ( ! this.enabled ) {\n\n\t\treturn;\n\n\t}\n\n\tfor ( let i = 0; i < this.mouseActions.length; i ++ ) {\n\n\t\tif ( this.mouseActions[ i ].mouse == 2 ) {\n\n\t\t\t//prevent only if button 2 is actually used\n\t\t\tevent.preventDefault();\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n}\n\nfunction onPointerCancel() {\n\n\tthis._touchStart.splice( 0, this._touchStart.length );\n\tthis._touchCurrent.splice( 0, this._touchCurrent.length );\n\tthis._input = INPUT.NONE;\n\n}\n\nfunction onPointerDown( event ) {\n\n}\n\nfunction onPointerDownWrap( event ) {\n    var centerX = domElement.clientWidth / 2;\n    var centerY = domElement.clientHeight / 2;\n\n    const dx = event.clientX - centerX;\n    const dy = event.clientY - centerY;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n\n\n\tif ( event.button == 0 && event.isPrimary ) {\n\n\t\tthis._downValid = true;\n\t\tthis._downEvents.push( event );\n\t\tthis._downStart = performance.now();\n\n\t} else {\n\n\t\tthis._downValid = false;\n\n\t}\n\n\tif ( event.pointerType == 'touch' && this._input != INPUT.CURSOR ) {\n\n\t\tthis._touchStart.push( event );\n\t\tthis._touchCurrent.push( event );\n\n\t\tswitch ( this._input ) {\n\n\t\t\tcase INPUT.NONE:\n\n\t\t\t\t//singleStart\n\t\t\t\tthis._input = INPUT.ONE_FINGER;\n\t\t\t\tthis.onSinglePanStart( event, 'ROTATE' );\n\n\t\t\t\twindow.addEventListener( 'pointermove', this._onPointerMove );\n\t\t\t\twindow.addEventListener( 'pointerup', this._onPointerUp );\n\n\t\t\t\tbreak;\n\n\t\t\tcase INPUT.ONE_FINGER:\n\t\t\tcase INPUT.ONE_FINGER_SWITCHED:\n\n\t\t\t\t//doubleStart\n\t\t\t\tthis._input = INPUT.TWO_FINGER;\n\n\t\t\t\tthis.onRotateStart();\n\t\t\t\tthis.onPinchStart();\n\t\t\t\tthis.onDoublePanStart();\n\n\t\t\t\tbreak;\n\n\t\t\tcase INPUT.TWO_FINGER:\n\n\t\t\t\t//multipleStart\n\t\t\t\tthis._input = INPUT.MULT_FINGER;\n\t\t\t\tthis.onTriplePanStart( event );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t} else if ( event.pointerType != 'touch' && this._input == INPUT.NONE ) {\n\n\t\tlet modifier = null;\n\n\t\tif ( event.ctrlKey || event.metaKey ) {\n\n\t\t\tmodifier = 'CTRL';\n\n\t\t} else if ( event.shiftKey ) {\n\n\t\t\tmodifier = 'SHIFT';\n\n\t\t}\n\n\t\tthis._mouseOp = this.getOpFromAction( event.button, modifier );\n\t\tif ( this._mouseOp != null ) {\n\n\t\t\twindow.addEventListener( 'pointermove', this._onPointerMove );\n\t\t\twindow.addEventListener( 'pointerup', this._onPointerUp );\n\n\t\t\t//singleStart\n\t\t\tthis._input = INPUT.CURSOR;\n\t\t\tthis._button = event.button;\n\t\t\tthis.onSinglePanStart( event, this._mouseOp );\n\n\t\t}\n\n\t}\n\n}\n\nfunction onPointerMove( event ) {\n\n\tif ( event.pointerType == 'touch' && this._input != INPUT.CURSOR ) {\n\n\t\tswitch ( this._input ) {\n\n\t\t\tcase INPUT.ONE_FINGER:\n\n\t\t\t\t//singleMove\n\t\t\t\tthis.updateTouchEvent( event );\n\n\t\t\t\tthis.onSinglePanMove( event, STATE.ROTATE );\n\t\t\t\tbreak;\n\n\t\t\tcase INPUT.ONE_FINGER_SWITCHED:\n\n\t\t\t\tconst movement = this.calculatePointersDistance( this._touchCurrent[ 0 ], event ) * this._devPxRatio;\n\n\t\t\t\tif ( movement >= this._switchSensibility ) {\n\n\t\t\t\t\t//singleMove\n\t\t\t\t\tthis._input = INPUT.ONE_FINGER;\n\t\t\t\t\tthis.updateTouchEvent( event );\n\n\t\t\t\t\tthis.onSinglePanStart( event, 'ROTATE' );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase INPUT.TWO_FINGER:\n\n\t\t\t\t//rotate/pan/pinchMove\n\t\t\t\tthis.updateTouchEvent( event );\n\n\t\t\t\tthis.onRotateMove();\n\t\t\t\tthis.onPinchMove();\n\t\t\t\tthis.onDoublePanMove();\n\n\t\t\t\tbreak;\n\n\t\t\tcase INPUT.MULT_FINGER:\n\n\t\t\t\t//multMove\n\t\t\t\tthis.updateTouchEvent( event );\n\n\t\t\t\tthis.onTriplePanMove( event );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t} else if ( event.pointerType != 'touch' && this._input == INPUT.CURSOR ) {\n\n\t\tlet modifier = null;\n\n\t\tif ( event.ctrlKey || event.metaKey ) {\n\n\t\t\tmodifier = 'CTRL';\n\n\t\t} else if ( event.shiftKey ) {\n\n\t\t\tmodifier = 'SHIFT';\n\n\t\t}\n\n\t\tconst mouseOpState = this.getOpStateFromAction( this._button, modifier );\n\n\t\tif ( mouseOpState != null ) {\n\n\t\t\tthis.onSinglePanMove( event, mouseOpState );\n\n\t\t}\n\n\t}\n\n\t//checkDistance\n\tif ( this._downValid ) {\n\n\t\tconst movement = this.calculatePointersDistance( this._downEvents[ this._downEvents.length - 1 ], event ) * this._devPxRatio;\n\t\tif ( movement > this._movementThreshold ) {\n\n\t\t\tthis._downValid = false;\n\n\t\t}\n\n\t}\n\n}\n\nfunction onPointerUp( event ) {\n\n\tif ( event.pointerType == 'touch' && this._input != INPUT.CURSOR ) {\n\n\t\tconst nTouch = this._touchCurrent.length;\n\n\t\tfor ( let i = 0; i < nTouch; i ++ ) {\n\n\t\t\tif ( this._touchCurrent[ i ].pointerId == event.pointerId ) {\n\n\t\t\t\tthis._touchCurrent.splice( i, 1 );\n\t\t\t\tthis._touchStart.splice( i, 1 );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tswitch ( this._input ) {\n\n\t\t\tcase INPUT.ONE_FINGER:\n\t\t\tcase INPUT.ONE_FINGER_SWITCHED:\n\n\t\t\t\t//singleEnd\n\t\t\t\twindow.removeEventListener( 'pointermove', this._onPointerMove );\n\t\t\t\twindow.removeEventListener( 'pointerup', this._onPointerUp );\n\n\t\t\t\tthis._input = INPUT.NONE;\n\t\t\t\tthis.onSinglePanEnd();\n\n\t\t\t\tbreak;\n\n\t\t\tcase INPUT.TWO_FINGER:\n\n\t\t\t\t//doubleEnd\n\t\t\t\tthis.onDoublePanEnd( event );\n\t\t\t\tthis.onPinchEnd( event );\n\t\t\t\tthis.onRotateEnd( event );\n\n\t\t\t\t//switching to singleStart\n\t\t\t\tthis._input = INPUT.ONE_FINGER_SWITCHED;\n\n\t\t\t\tbreak;\n\n\t\t\tcase INPUT.MULT_FINGER:\n\n\t\t\t\tif ( this._touchCurrent.length == 0 ) {\n\n\t\t\t\t\twindow.removeEventListener( 'pointermove', this._onPointerMove );\n\t\t\t\t\twindow.removeEventListener( 'pointerup', this._onPointerUp );\n\n\t\t\t\t\t//multCancel\n\t\t\t\t\tthis._input = INPUT.NONE;\n\t\t\t\t\tthis.onTriplePanEnd();\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t} else if ( event.pointerType != 'touch' && this._input == INPUT.CURSOR ) {\n\n\t\twindow.removeEventListener( 'pointermove', this._onPointerMove );\n\t\twindow.removeEventListener( 'pointerup', this._onPointerUp );\n\n\t\tthis._input = INPUT.NONE;\n\t\tthis.onSinglePanEnd();\n\t\tthis._button = - 1;\n\n\t}\n\n\tif ( event.isPrimary ) {\n\n\t\tif ( this._downValid ) {\n\n\t\t\tconst downTime = event.timeStamp - this._downEvents[ this._downEvents.length - 1 ].timeStamp;\n\n\t\t\tif ( downTime <= this._maxDownTime ) {\n\n\t\t\t\tif ( this._nclicks == 0 ) {\n\n\t\t\t\t\t//first valid click detected\n\t\t\t\t\tthis._nclicks = 1;\n\t\t\t\t\tthis._clickStart = performance.now();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst clickInterval = event.timeStamp - this._clickStart;\n\t\t\t\t\tconst movement = this.calculatePointersDistance( this._downEvents[ 1 ], this._downEvents[ 0 ] ) * this._devPxRatio;\n\n\t\t\t\t\tif ( clickInterval <= this._maxInterval && movement <= this._posThreshold ) {\n\n\t\t\t\t\t\t//second valid click detected\n\t\t\t\t\t\t//fire double tap and reset values\n\t\t\t\t\t\tthis._nclicks = 0;\n\t\t\t\t\t\tthis._downEvents.splice( 0, this._downEvents.length );\n\t\t\t\t\t\tthis.onDoubleTap( event );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t//new 'first click'\n\t\t\t\t\t\tthis._nclicks = 1;\n\t\t\t\t\t\tthis._downEvents.shift();\n\t\t\t\t\t\tthis._clickStart = performance.now();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis._downValid = false;\n\t\t\t\tthis._nclicks = 0;\n\t\t\t\tthis._downEvents.splice( 0, this._downEvents.length );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis._nclicks = 0;\n\t\t\tthis._downEvents.splice( 0, this._downEvents.length );\n\n\t\t}\n\n\t}\n\n}\n\nfunction onWheel( event ) {\n\n\tif ( this.enabled && this.enableZoom ) {\n\n\t\tlet modifier = null;\n\n\t\tif ( event.ctrlKey || event.metaKey ) {\n\n\t\t\tmodifier = 'CTRL';\n\n\t\t} else if ( event.shiftKey ) {\n\n\t\t\tmodifier = 'SHIFT';\n\n\t\t}\n\n\t\tconst mouseOp = this.getOpFromAction( 'WHEEL', modifier );\n\n\t\tif ( mouseOp != null ) {\n\n\t\t\tevent.preventDefault();\n\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\tconst notchDeltaY = 125; //distance of one notch of mouse wheel\n\t\t\tlet sgn = event.deltaY / notchDeltaY;\n\n\t\t\tlet size = 1;\n\n\t\t\tif ( sgn > 0 ) {\n\n\t\t\t\tsize = 1 / this.scaleFactor;\n\n\t\t\t} else if ( sgn < 0 ) {\n\n\t\t\t\tsize = this.scaleFactor;\n\n\t\t\t}\n\n\t\t\tswitch ( mouseOp ) {\n\n\t\t\t\tcase 'ZOOM':\n\n\t\t\t\t\tthis.updateTbState( STATE.SCALE, true );\n\n\t\t\t\t\tif ( sgn > 0 ) {\n\n\t\t\t\t\t\tsize = 1 / ( Math.pow( this.scaleFactor, sgn ) );\n\n\t\t\t\t\t} else if ( sgn < 0 ) {\n\n\t\t\t\t\t\tsize = Math.pow( this.scaleFactor, - sgn );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( this.cursorZoom && this.enablePan ) {\n\n\t\t\t\t\t\tlet scalePoint;\n\n\t\t\t\t\t\tif ( this.camera.isOrthographicCamera ) {\n\n\t\t\t\t\t\t\tscalePoint = this.unprojectOnTbPlane( this.camera, event.clientX, event.clientY, this.domElement ).applyQuaternion( this.camera.quaternion ).multiplyScalar( 1 / this.camera.zoom ).add( this._gizmos.position );\n\n\t\t\t\t\t\t} else if ( this.camera.isPerspectiveCamera ) {\n\n\t\t\t\t\t\t\tscalePoint = this.unprojectOnTbPlane( this.camera, event.clientX, event.clientY, this.domElement ).applyQuaternion( this.camera.quaternion ).add( this._gizmos.position );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.applyTransformMatrix( this.scale( size, scalePoint ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.applyTransformMatrix( this.scale( size, this._gizmos.position ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( this._grid != null ) {\n\n\t\t\t\t\t\tthis.disposeGrid();\n\t\t\t\t\t\tthis.drawGrid();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.updateTbState( STATE.IDLE, false );\n\n\t\t\t\t\tthis.dispatchEvent( _changeEvent );\n\t\t\t\t\tthis.dispatchEvent( _endEvent );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'FOV':\n\n\t\t\t\t\tif ( this.camera.isPerspectiveCamera ) {\n\n\t\t\t\t\t\tthis.updateTbState( STATE.FOV, true );\n\n\n\t\t\t\t\t\t//Vertigo effect\n\n\t\t\t\t\t\t//\t  fov / 2\n\t\t\t\t\t\t//\t\t|\\\n\t\t\t\t\t\t//\t\t| \\\n\t\t\t\t\t\t//\t\t|  \\\n\t\t\t\t\t\t//\tx\t|\t\\\n\t\t\t\t\t\t//\t\t| \t \\\n\t\t\t\t\t\t//\t\t| \t  \\\n\t\t\t\t\t\t//\t\t| _ _ _\\\n\t\t\t\t\t\t//\t\t\ty\n\n\t\t\t\t\t\t//check for iOs shift shortcut\n\t\t\t\t\t\tif ( event.deltaX != 0 ) {\n\n\t\t\t\t\t\t\tsgn = event.deltaX / notchDeltaY;\n\n\t\t\t\t\t\t\tsize = 1;\n\n\t\t\t\t\t\t\tif ( sgn > 0 ) {\n\n\t\t\t\t\t\t\t\tsize = 1 / ( Math.pow( this.scaleFactor, sgn ) );\n\n\t\t\t\t\t\t\t} else if ( sgn < 0 ) {\n\n\t\t\t\t\t\t\t\tsize = Math.pow( this.scaleFactor, - sgn );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._v3_1.setFromMatrixPosition( this._cameraMatrixState );\n\t\t\t\t\t\tconst x = this._v3_1.distanceTo( this._gizmos.position );\n\t\t\t\t\t\tlet xNew = x / size;\t//distance between camera and gizmos if scale(size, scalepoint) would be performed\n\n\t\t\t\t\t\t//check min and max distance\n\t\t\t\t\t\txNew = MathUtils.clamp( xNew, this.minDistance, this.maxDistance );\n\n\t\t\t\t\t\tconst y = x * Math.tan( MathUtils.DEG2RAD * this.camera.fov * 0.5 );\n\n\t\t\t\t\t\t//calculate new fov\n\t\t\t\t\t\tlet newFov = MathUtils.RAD2DEG * ( Math.atan( y / xNew ) * 2 );\n\n\t\t\t\t\t\t//check min and max fov\n\t\t\t\t\t\tif ( newFov > this.maxFov ) {\n\n\t\t\t\t\t\t\tnewFov = this.maxFov;\n\n\t\t\t\t\t\t} else if ( newFov < this.minFov ) {\n\n\t\t\t\t\t\t\tnewFov = this.minFov;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst newDistance = y / Math.tan( MathUtils.DEG2RAD * ( newFov / 2 ) );\n\t\t\t\t\t\tsize = x / newDistance;\n\n\t\t\t\t\t\tthis.setFov( newFov );\n\t\t\t\t\t\tthis.applyTransformMatrix( this.scale( size, this._gizmos.position, false ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( this._grid != null ) {\n\n\t\t\t\t\t\tthis.disposeGrid();\n\t\t\t\t\t\tthis.drawGrid();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.updateTbState( STATE.IDLE, false );\n\n\t\t\t\t\tthis.dispatchEvent( _changeEvent );\n\t\t\t\t\tthis.dispatchEvent( _endEvent );\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nexport { ArcballControls };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}